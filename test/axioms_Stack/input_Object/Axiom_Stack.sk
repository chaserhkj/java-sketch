package Axiom_Stack;

Object object() { 
   return Object_Object(new Object(__cid=Object()));
}
Object push(Object s, Object o) { 
   return (s.__cid == Object() || s.__cid == Push() || s.__cid == Pop() ? Push_Push_Object_Object(new Object(__cid=Push()), s, o) : null);
}
Object pop(Object s) { 
   return (s.__cid == Object() || s.__cid == Push() || s.__cid == Pop() ? Pop_Pop_Object(new Object(__cid=Pop()), s): null);
}
Object error() { 
   return Error_Error(new Object(__cid=Error())); 
}

Object xform (Object t, int dice) {
   Object t1; Object tt1;

   if (t.__cid == Pop()) {
      t1 = t.s_Pop;
      if (t1.__cid == Push()) {
         if (dice%2 == 0) {
	    return t1.o_Push;
         } else {
            return t;
         }
      } else if (t1.__cid == Pop()) {
         // TODO: Not sure what to do here
	 return t;
      } else {
         return error();
      }
   } else if (t.__cid == Push()) {
      t1 = t.s_Push;
      if (dice%2 == 0) {
         dice /= 2;
	 t1 = xform(t1, dice);
         return push(t1, t.o_Push);
      } else {
         return t;
      }
   } else {
      return t;
   }

}

bit equals_Axiom(Object self, Object obj) {
  if (self.__cid != obj.__cid) {
     return false;
  } else {
     if (self.__cid == Object() && obj.__cid == Object()) {
        return self == obj;
     } else if (self.__cid == Push() && obj.__cid == Push()) {
	if (self.o_Push == obj.o_Push) {
	   return equals_Axiom(self.s_Push, obj.s_Push);
	} 
     } else if (self.__cid == Pop() && obj.__cid == Pop()) {
	return equals_Axiom(self.s_Pop, obj.s_Pop);
     } 

     return false;
  }
}