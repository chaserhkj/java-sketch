package meta;

adt H {
  Hash    { }
  Obj	  { Object o; }
  Get     { H h; H k; }
  Put     { H h; H k; H v; }
  Remove  { H h; H k; }
  Error   { }
}

H get_xform (H h, H k, int depth) {
  switch (h) {
     case Put:    {
        if (h.k == k) {
	   if (depth == 0) {
	      return h.v;
	   } else {
	      return get_xform(h.h, k, depth-1);
	   }
	} else {
	   return get_xform(h.h, k, depth);
	}
     }
     case Get:    return null;
     case Remove: {
        return h.k == k ? get_xform(h.h, k, depth+1) : get_xform(h.h, k, depth);
     }
     case Hash:   return null;
     case Obj:    return null;
     case Error:  return null;
  }
}

Object object() {
   return new Object(__cid = Object(), h=new Obj(o=new Object(__cid = Object())));
}

Object hashMap() {
   return new Object(__cid = HashMap(), h=new Hash());
}

Object get(H h, H k) {
   return new Object(__cid = HashMap(), h=new Get(h=h, k=k));
}

Object remove(H h, H k) {
   return new Object(__cid = HashMap(), h=new Remove(h=h, k=k));
}

Object put(H h, H k, H v) {
   return new Object(__cid = HashMap(), h=new Put(h=h, k=k, v=v));
}

H xform(H h, int dice) {
  switch (h) {
     case Put:   return h;
     case Get:   {
        if (dice%2 == 0) {
           return get_xform(h.h, h.k, 0);
	} else {
	   return h;
	}
     }
     case Remove:  return h;
     case Hash:    return h;
     case Obj:     return h;
     case Error:   return h;
  }
}

// distinct class IDs
int Object()               { return 1; }
int HashMap()              { return 24; }

// Uninterpreted functions
