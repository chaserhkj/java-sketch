SKETCH version 1.7.5
Benchmark = /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/sk_Tester/main.sk
array.sk:5: Making final Array_bit@array.length
array.sk:5: Making final Object._int
array.sk:10: Making final Array_char@array.length
array.sk:15: Making final Array_int@array.length
array.sk:20: Making final Array_float@array.length
array.sk:25: Making final Array_double@array.length
array.sk:30: Making final Array_Object@array.length
[SATBackend] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[SATBackend] MAX LOOP UNROLLING = 15
[SATBackend] MAX FUNC INLINING  = 1
estimated size of main__Wrapper_Tester
stmt cnt: 2
callee main_Tester : 16

[SATBackend] After prog.accept(partialEval)
[SATBackend] OFILE = sk_Tester
searching for file null
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/cegis/src/SketchSolver/cegis
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/cegis
searching for file cegis/src/SketchSolver/cegis
searching for file ../sketch-backend/src/SketchSolver/cegis
searching for file ../sketch-backend/bindings/cegis
searching for file /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/cegis-1.7.5
searching for file /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/cegis
searching for file /usr/bin/cegis
searching for file /usr/bin/src/SketchSolver/cegis
searching for file /usr/bin/../sketch-backend/src/SketchSolver/cegis
searching for file /usr/bin/../sketch-backend/bindings/cegis
searching for file /bin/cegis
searching for file /bin/src/SketchSolver/cegis
searching for file /bin/../sketch-backend/src/SketchSolver/cegis
searching for file /bin/../sketch-backend/bindings/cegis
searching for file /usr/sbin/cegis
searching for file /usr/sbin/src/SketchSolver/cegis
searching for file /usr/sbin/../sketch-backend/src/SketchSolver/cegis
searching for file /usr/sbin/../sketch-backend/bindings/cegis
searching for file /sbin/cegis
searching for file /sbin/src/SketchSolver/cegis
searching for file /sbin/../sketch-backend/src/SketchSolver/cegis
searching for file /sbin/../sketch-backend/bindings/cegis
searching for file /usr/local/bin/cegis
searching for file /usr/local/bin/src/SketchSolver/cegis
searching for file /usr/local/bin/../sketch-backend/src/SketchSolver/cegis
searching for file /usr/local/bin/../sketch-backend/bindings/cegis
searching for file /Applications/Racket v6.10/bin/cegis
searching for file /Applications/Racket v6.10/bin/src/SketchSolver/cegis
searching for file /Applications/Racket v6.10/bin/../sketch-backend/src/SketchSolver/cegis
searching for file /Applications/Racket v6.10/bin/../sketch-backend/bindings/cegis
searching for file /Library/TeX/texbin/cegis
searching for file /Library/TeX/texbin/src/SketchSolver/cegis
searching for file /Library/TeX/texbin/../sketch-backend/src/SketchSolver/cegis
searching for file /Library/TeX/texbin/../sketch-backend/bindings/cegis
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/cegis
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/src/SketchSolver/cegis
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/../sketch-backend/src/SketchSolver/cegis
resolved cegis to path /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-backend/src/SketchSolver/cegis
[SATBackend] Launching: /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-backend/src/SketchSolver/cegis --bnd-inbits 5 --boundmode CALLNAME --verbosity 13 --print-version -simiters 4 --assumebcheck --bnd-inline-amnt 1 -angelictupledepth 1 -srctupledepth 2 -sprandbias 1 -o /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/tmp/sk_Tester/solution0-0 /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/tmp/sk_Tester/input0.tmp 
Overriding inputs with 5
boundmode = CALLNAME
assuming  bounds checks
SOLVER RAND SEED = 1523134866
 optimization level = 6
Reading SKETCH Program in File /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/tmp/sk_Tester/input0.tmp
CREATING main__Wrapper_Tester
size = 4
after ba size = 4
CREATING main__WrapperNospec_Tester
size = 0
after ba size = 0
CREATING main_Tester
size = 117
after ba size = 117
CREATING Object_meta
size = 3
after ba size = 3
CREATING Object_Object_Object
size = 34
after ba size = 34
CREATING testOpenSSL_Tester
size = 952
after ba size = 952
CREATING testJCECipher_Tester
size = 1079
after ba size = 1079
CREATING OpenSSLCipher_meta
size = 3
after ba size = 3
CREATING String_meta
size = 3
after ba size = 3
CREATING Wrap_Array_char_array
size = 44
after ba size = 44
CREATING String_String_char_int_int_String
size = 1098
after ba size = 1098
CREATING OpenSSLCipher_OpenSSLCipher_String_String_OpenSSLCipher
size = 44
after ba size = 44
CREATING toString_int_Integer
size = 3724
after ba size = 3724
CREATING getBytes_String
size = 98
after ba size = 98
CREATING SecretKeySpec_SecretKeySpec_SecretKeySpec
size = 44
after ba size = 44
CREATING encrypt_byte_SecretKeySpec_byte_OpenSSLCipher
size = 84
after ba size = 84
CREATING decrypt_byte_SecretKeySpec_byte_OpenSSLCipher
size = 85
after ba size = 85
CREATING arraysEquals_byte_byte_Arrays
size = 1170
after ba size = 1170
CREATING JCECipher_meta
size = 3
after ba size = 3
CREATING JCECipher_JCECipher_String_String_String_JCECipher
size = 46
after ba size = 46
CREATING encrypt_byte_SecretKeySpec_byte_JCECipher
size = 84
after ba size = 84
CREATING decrypt_byte_SecretKeySpec_byte_JCECipher
size = 85
after ba size = 85
CREATING Array_meta
size = 3
after ba size = 3
CREATING toString_String
size = 34
after ba size = 34
CREATING getBytes_String_String
Found Cycle of size 38; Breaking.
size = 2538
after ba size = 2538
CREATING SecretKeySpec_meta
size = 3
after ba size = 3
CREATING translate_boolean_byte_SecretKeySpec_byte_OpenSSLCipher
Found Cycle of size 9; Breaking.
size = 1814
after ba size = 1814
CREATING translate_boolean_byte_SecretKeySpec_byte_JCECipher
Found Cycle of size 13; Breaking.
size = 915
after ba size = 915
CREATING length_String
size = 41
after ba size = 41
CREATING charAt_int_String
size = 112
after ba size = 112
CREATING getCipher_boolean_SecretKeySpec_byte_JCECipher
size = 498
after ba size = 498
CREATING xform_update_Cipher_byte_int_int_byte_int_Cipher
size = 46
after ba size = 46
CREATING Cipher_meta
size = 3
after ba size = 3
CREATING updateb_Object_byte_int_int_byte_int_Cipher
size = 55
after ba size = 55
CREATING xform_doFinale_Cipher_byte_int_int_byte_int_Cipher
size = 213
after ba size = 213
CREATING doFinaleb_Object_byte_int_int_byte_int_Cipher
size = 55
after ba size = 55
CREATING doFinal_Object_Object_Cipher
size = 51
after ba size = 51
CREATING doFinalb_Object_Object_Cipher
size = 51
after ba size = 51
CREATING xform_doFinal_Cipher_Object_Cipher
size = 1251
after ba size = 1251
CREATING copyOf_byte_int_Arrays
size = 1540
after ba size = 1540
CREATING getInstance_String_String_Cipher
size = 71
after ba size = 71
CREATING IvParameterSpec_meta
size = 3
after ba size = 3
CREATING IvParameterSpec_IvParameterSpec_byte_IvParameterSpec
size = 35
after ba size = 35
CREATING init_Object_int_SecretKeySpec_AlgorithmParameterSpec_Cipher
size = 53
after ba size = 53
CREATING initb_Object_int_SecretKeySpec_AlgorithmParameterSpec_Cipher
size = 53
after ba size = 53
CREATING xform_equals_SecretKeySpec_Object_SecretKeySpec
size = 143
after ba size = 143
CREATING Cipher_Object_String_String_Cipher
size = 45
after ba size = 45
* before  EVERYTHING: main__WrapperNospec_Tester::SPEC nodes = 0	 main__Wrapper_Tester::SKETCH nodes = 4
 INBITS = 5
 CBITS  = 5
 input_ints = 0 	 input_bits = 0
 Inlining amount = 1
 Inlining functions in the sketch.
inlined 1 new size =45
inlined 4 new size =1831
Found Cycle of size 45; Breaking.
Found Cycle of size 42; Breaking.
inlined 90 new size =21243
Found Cycle of size 90; Breaking.
inlined 39 new size =37262
Found Cycle of size 10; Breaking.
Found Cycle of size 29; Breaking.
Found Cycle of size 60; Breaking.
inlined 135 new size =46455
Found Cycle of size 282; Breaking.
Found Cycle of size 253; Breaking.
Found Cycle of size 289; Breaking.
inlined 60 new size =43232
Found Cycle of size 579; Breaking.
inlined 12 new size =12359
inlined 2 new size =12285
inlined 0 new size =12285
END OF STEP 0
 Inlining functions in the spec.
inlined 0 new size =0
END OF STEP 0
Bailing out
after Creating Miter: Problem nodes = 12254
* Final Problem size: Problem nodes = 12254
  # OF CONTROLS:    52
 control_ints = 34 	 control_bits = 18
inputSize = 0	ctrlSize = 256
Random seeds = 1
!+ 0000000001010000000000000000110000010000000001000000001010110011001000001000000000001010100010000000110000000001010111000010000000000000101001000000000010000110000011100000000100000001110000000001010000101000110000000100001110011000011100100000000010000100
!+ H__39_194:0
H__37_194:0
H__32_194:0
H__25_194:0
H__24_194:0
H__17_194_193:0
H__12_194_193:0
H__5_194_193:0
H__4_194_193:0
H__38_194:1
H__0:2
H__1:0
H__26_194:48
H__27_194:16
H__28_194:0
H__29_194:1
H__30_194:84
H__31_194:25
H__33_194:65
H__34_194:0
H__35_194:80
H__36_194:34
H__6_194_193:64
H__7_194_193:1
H__8_194_193:40
H__9_194_193:7
H__10_194_193:1
H__11_194_193:0
H__13_194_193:37
H__14_194_193:0
H__15_194_193:4
H__16_194_193:3
H__2:7
H__3:16
H__17_136:0
H__12_136:0
H__5_136:0
H__4_136:0
H__18_194_193:0
H__19_194_193_194_193:1
H__19_136_136:1
H__18_136:1
H__6_136:0
H__7_136:20
H__8_136:20
H__9_136:6
H__10_136:8
H__11_136:78
H__13_136:97
H__14_136:9
H__15_136:64
H__16_136:16

BEG CHECK
 * After optims it became = 2 was 12254
Assert at Tester.sk:27 (0)
Simulation found a cex by random testing:  0.001 ms 
END CHECK
********  0	ftime= 0	ctime= 0.018
!% 
!% 
BEG FIND
Level 1  intsize = 2
 * After optims it became = 12254 was 12254
 * After all optims it became = 12254
 finder  hits = 17039	 bstoreObjs=12331	 sstorePages=11
hitcount 	0	3964	3
hitcount 	1	7277	2
hitcount 	2	386	3
hitcount 	3	44	3
hitcount 	4	18	2
hitcount 	5	31	2
hitcount 	6	16	2
hitcount 	7	11	3
hitcount 	8	16	3
hitcount 	9	13	2
hitcount 	10	5	3
hitcount 	11	13	4
hitcount 	12	9	3
hitcount 	13	6	2
hitcount 	14	9	4
hitcount 	15	512	3
hitcount 	28	1	1
bucketsPerDepth 	1	1
bucketsPerDepth 	2	5
bucketsPerDepth 	3	70
bucketsPerDepth 	4	237
bucketsPerDepth 	5	299
bucketsPerDepth 	6	200
bucketsPerDepth 	7	111
bucketsPerDepth 	8	70
bucketsPerDepth 	9	27
bucketsPerDepth 	10	3
bucketsPerDepth 	11	1
* TIME TO ADD INPUT :  999.386 ms 
DECISIONS START = 0
f# %assign: 8 clauses: 31232 learn: 1 restart: 1 decision: 6732 propagated: 25649
END FIND
!+ 0111101001000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000111110000000000000000000000000000000000000000000000000000000000000000000000000
!+ H__39_194:0
H__37_194:1
H__32_194:1
H__25_194:1
H__24_194:1
H__17_194_193:0
H__12_194_193:1
H__5_194_193:0
H__4_194_193:0
H__38_194:1
H__0:0
H__1:0
H__26_194:0
H__27_194:0
H__28_194:0
H__29_194:0
H__30_194:6
H__31_194:0
H__33_194:0
H__34_194:0
H__35_194:0
H__36_194:0
H__6_194_193:0
H__7_194_193:0
H__8_194_193:0
H__9_194_193:0
H__10_194_193:0
H__11_194_193:0
H__13_194_193:0
H__14_194_193:0
H__15_194_193:0
H__16_194_193:1
H__2:0
H__3:0
H__17_136:1
H__12_136:1
H__5_136:1
H__4_136:1
H__18_194_193:1
H__19_194_193_194_193:0
H__19_136_136:0
H__18_136:0
H__6_136:0
H__7_136:0
H__8_136:0
H__9_136:0
H__10_136:0
H__11_136:0
H__13_136:0
H__14_136:0
H__15_136:0
H__16_136:0

BEG CHECK
 * After optims it became = 0 was 12254
Simulation no cex:  0 ms 
CONTROL: growing l=2 inputs to size 3
Simulation no cex:  0 ms 
CONTROL: growing l=2 inputs to size 4
Simulation no cex:  0 ms 
CONTROL: growing l=2 inputs to size 5
Simulation no cex:  0 ms 
END CHECK
********  1	ftime= 999.391	ctime= 0.018
 *GOT THE CORRECT ANSWER IN 2 iterations.
 *FIND TIME 999.391 CHECK TIME 0.036 TOTAL TIME 999.428
VALUES H__0: 0, H__1: 0, H__10_136: 0, H__10_194_193: 0, H__11_136: 0, H__11_194_193: 0, H__12_136: 1, H__12_194_193: 1, H__13_136: 0, H__13_194_193: 0, H__14_136: 0, H__14_194_193: 0, H__15_136: 0, H__15_194_193: 0, H__16_136: 0, H__16_194_193: 1, H__17_136: 1, H__17_194_193: 0, H__18_136: 0, H__18_194_193: 1, H__19_136_136: 0, H__19_194_193_194_193: 0, H__2: 0, H__24_194: 1, H__25_194: 1, H__26_194: 0, H__27_194: 0, H__28_194: 0, H__29_194: 0, H__3: 0, H__30_194: 6, H__31_194: 0, H__32_194: 1, H__33_194: 0, H__34_194: 0, H__35_194: 0, H__36_194: 0, H__37_194: 1, H__38_194: 1, H__39_194: 0, H__4_136: 1, H__4_194_193: 0, H__5_136: 1, H__5_194_193: 0, H__6_136: 0, H__6_194_193: 0, H__7_136: 0, H__7_194_193: 0, H__8_136: 0, H__8_194_193: 0, H__9_136: 0, H__9_194_193: 0, 
RESULT = 2  
**ROUND 0 : 0 Round time:  999.76 ms 
RNDDEG = -1
return 0

----- Statistics -----
Total elapsed time (ms):  1000.19
Model building time (ms): 0.4
Solution time (ms):       999.76
Max virtual mem (bytes):  0
Max resident mem (bytes): 0
Max private mem (bytes):  0
ALL CORRECT
[SATBackend] Stats for last run:
      [solution stats]
      successful? ---------------------> true
      elapsed time (s) ----------------> 1.381
      model building time (s) ---------> 0.0
      solution time (s) ---------------> 0.999
      max memory usage (MiB) ----------> 0.0
      [SAT-specific solution stats]
      initial number of nodes ---------> -1
      number of nodes after opts ------> -1
      number of controls --------------> -1
      total number of control bits ----> -1

[SATBackend] Solver exit value: 0
[SATBackend] Not Deleting
/* BEGIN PACKAGE JCECipher*/
package JCECipher{
  /*JCECipher.sk:7*/
  
void JCECipher_JCECipher_String_String_String (Object self, Object provider, Object algorithm, Object transformation, ref Object _out)/*JCECipher.sk:7*/
  {
    self.provider_JCECipher = provider;
    self.algorithm_JCECipher = algorithm;
    self.transformation_JCECipher = transformation;
    _out = self;
    return;
  }
  /*JCECipher.sk:34*/
  
void decrypt_byte_SecretKeySpec_byte (Object self, Object data, Object key, Object IV, ref Object _out)/*JCECipher.sk:34*/
  {
    Object@Object _out_s24 = null;
    translate_boolean_byte_SecretKeySpec_byte@JCECipher(self, new Object@Object(__cid=-4, _bit=0), data, key, IV, _out_s24);
    _out = _out_s24;
    return;
  }
  /*JCECipher.sk:30*/
  
void encrypt_byte_SecretKeySpec_byte (Object self, Object data, Object key, Object IV, ref Object _out)/*JCECipher.sk:30*/
  {
    Object@Object _out_s91 = null;
    translate_boolean_byte_SecretKeySpec_byte@JCECipher(self, new Object@Object(__cid=-4, _bit=1), data, key, IV, _out_s91);
    _out = _out_s91;
    return;
  }
  /*JCECipher.sk:14*/
  
void getCipher_boolean_SecretKeySpec_byte (Object self, Object isEncryption, Object key, Object IV, ref Object _out)/*JCECipher.sk:14*/
  {
    Object@Object cipher_s65 = null;
    getInstance_String_String@Cipher(self.transformation_JCECipher, self.provider_JCECipher, cipher_s65);
    Object@Object keyValue_s67 = null;
    SecretKeySpec_SecretKeySpec@SecretKeySpec(keyValue_s67);
    int IVspec_s69 = 0;
    IvParameterSpec@meta(IVspec_s69);
    Object@Object IVspec_s71 = null;
    IvParameterSpec_IvParameterSpec_byte@IvParameterSpec(new Object@Object(__cid=IVspec_s69), IV, IVspec_s71)//{};
    if(isEncryption._bit)/*JCECipher.sk:19*/
    {
      int _out_s73 = 0;
      Cipher@meta(_out_s73);
      if((cipher_s65.__cid) == (new Object@Object(__cid=-2, _int=_out_s73)._int))/*JCECipher.sk:20*/
      {
        Object@Object _out_s75 = null;
        init_Object_int_SecretKeySpec_AlgorithmParameterSpec@Cipher(cipher_s65, new Object@Object(__cid=-2, _int=0), keyValue_s67, IVspec_s71, _out_s75);
      }
      int cipher_s77 = 0;
      Cipher@meta(cipher_s77);
      Object@Object _pac_sc_s78 = null;
      if((cipher_s65.__cid) == (new Object@Object(__cid=-2, _int=cipher_s77)._int))/*JCECipher.sk:21*/
      {
        Object@Object cipher_s80 = null;
        initb_Object_int_SecretKeySpec_AlgorithmParameterSpec@Cipher(cipher_s65, new Object@Object(__cid=-2, _int=0), keyValue_s67, IVspec_s71, cipher_s80);
        _pac_sc_s78 = cipher_s80;
      }
      else
      {
        _pac_sc_s78 = null;
      }
      _out = _pac_sc_s78;
    }
    else
    {
      int _out_s82 = 0;
      Cipher@meta(_out_s82);
      if((cipher_s65.__cid) == (new Object@Object(__cid=-2, _int=_out_s82)._int))/*JCECipher.sk:24*/
      {
        Object@Object _out_s84 = null;
        init_Object_int_SecretKeySpec_AlgorithmParameterSpec@Cipher(cipher_s65, new Object@Object(__cid=-2, _int=0), keyValue_s67, IVspec_s71, _out_s84);
      }
      int cipher_s86 = 0;
      Cipher@meta(cipher_s86);
      Object@Object _pac_sc_s87 = null;
      if((cipher_s65.__cid) == (new Object@Object(__cid=-2, _int=cipher_s86)._int))/*JCECipher.sk:25*/
      {
        Object@Object cipher_s89 = null;
        initb_Object_int_SecretKeySpec_AlgorithmParameterSpec@Cipher(cipher_s65, new Object@Object(__cid=-2, _int=0), keyValue_s67, IVspec_s71, cipher_s89);
        _pac_sc_s87 = cipher_s89;
      }
      else
      {
        _pac_sc_s87 = null;
      }
      _out = _pac_sc_s87;
    }
    return;
  }
  /*JCECipher.sk:78*/
  
void translate_boolean_byte_SecretKeySpec_byte (Object self, Object isEncryption, Object data, Object key, Object IV, ref Object _out)/*JCECipher.sk:78*/
  {
    Object@Object _out_s26 = null;
    Object@Object cipher_s28 = null;
    getCipher_boolean_SecretKeySpec_byte@JCECipher(self, isEncryption, key, IV, cipher_s28);
    Object@Object updateBytes_s30 = null;
    xform_update_Cipher_byte_int_int_byte_int@Cipher(cipher_s28._cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s26, new Object@Object(__cid=-2, _int=0), updateBytes_s30);
    int cipher_s32 = 0;
    Cipher@meta(cipher_s32);
    Object@Object _pac_sc_s33 = null;
    if((cipher_s28.__cid) == (new Object@Object(__cid=-2, _int=cipher_s32)._int))/*JCECipher.sk:49*/
    {
      Object@Object cipher_s35 = null;
      updateb_Object_byte_int_int_byte_int@Cipher(cipher_s28, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s26, new Object@Object(__cid=-2, _int=0), cipher_s35);
      _pac_sc_s33 = cipher_s35;
    }
    else
    {
      _pac_sc_s33 = null;
    }
    Object@Object finalBytes_s37 = null;
    xform_doFinale_Cipher_byte_int_int_byte_int@Cipher(_pac_sc_s33._cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s26, updateBytes_s30, finalBytes_s37);
    int cipher_s39 = 0;
    Cipher@meta(cipher_s39);
    Object@Object _pac_sc_s40 = null;
    if((_pac_sc_s33.__cid) == (new Object@Object(__cid=-2, _int=cipher_s39)._int))/*JCECipher.sk:53*/
    {
      Object@Object cipher_s42 = null;
      doFinaleb_Object_byte_int_int_byte_int@Cipher(_pac_sc_s33, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s26, updateBytes_s30, cipher_s42);
      _pac_sc_s40 = cipher_s42;
    }
    else
    {
      _pac_sc_s40 = null;
    }
    if(isEncryption._bit)/*JCECipher.sk:56*/
    {
      int cipherText_s44 = 0;
      Cipher@meta(cipherText_s44);
      Object@Object _pac_sc_s45 = null;
      if((_pac_sc_s40.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s44)._int))/*JCECipher.sk:57*/
      {
        Object@Object cipherText_s47 = null;
        doFinal_Object_Object@Cipher(_pac_sc_s40, data, cipherText_s47);
        _pac_sc_s45 = cipherText_s47;
      }
      else
      {
        _pac_sc_s45 = null;
      }
      _out_s26 = _pac_sc_s45;
      int cipher_s49 = 0;
      Cipher@meta(cipher_s49);
      if((_pac_sc_s40.__cid) == (new Object@Object(__cid=-2, _int=cipher_s49)._int))/*JCECipher.sk:58*/
      {
        Object@Object cipher_s52 = null;
        doFinalb_Object_Object@Cipher(_pac_sc_s40, data, cipher_s52);
      }
    }
    else
    {
      Object@Object cipherText_s54 = null;
      xform_doFinal_Cipher_Object@Cipher(_pac_sc_s40._cipher, data, cipherText_s54);
      _out_s26 = cipherText_s54;
      int cipher_s56 = 0;
      Cipher@meta(cipher_s56);
      if((_pac_sc_s40.__cid) == (new Object@Object(__cid=-2, _int=cipher_s56)._int))/*JCECipher.sk:61*/
      {
        Object@Object cipher_s59 = null;
        doFinalb_Object_Object@Cipher(_pac_sc_s40, data, cipher_s59);
      }
    }
    _out = _out_s26;
    return;
  }
  /* END PACKAGE JCECipher*/
}
/* BEGIN PACKAGE Tester*/
package Tester{
  /*Tester.sk:7*/
  
void _main ()/*Tester.sk:7*/
  {
    int self_s93 = 0;
    Object@meta(self_s93);
    Object@Object self_s95 = null;
    Object_Object@Object(new Object@Object(__cid=self_s93), self_s95)//{};
    testOpenSSL@Tester(self_s95);
    testJCECipher@Tester(self_s95);
  }
  /*Tester.sk:7*/
  
void main__Wrapper ()  implements main__WrapperNospec/*Tester.sk:7*/
  {
    _main();
  }
  /*Tester.sk:7*/
  
void main__WrapperNospec ()/*Tester.sk:7*/
  { }
  /*Tester.sk:31*/
  
void testJCECipher (Object self)/*Tester.sk:31*/
  {
    int oc_s97 = 0;
    JCECipher@meta(oc_s97);
    int oc_s99 = 0;
    String@meta(oc_s99);
    Object@Object oc_s101 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=9), A={'P','R','O','V','I','D','E','R','\0'}), oc_s101);
    Object@Object oc_s103 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s99), oc_s101, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=8), oc_s103)//{};
    int oc_s105 = 0;
    String@meta(oc_s105);
    Object@Object oc_s107 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=4), A={'A','E','S','\0'}), oc_s107);
    Object@Object oc_s109 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s105), oc_s107, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=3), oc_s109)//{};
    int oc_s111 = 0;
    String@meta(oc_s111);
    Object@Object oc_s113 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=15), A={'T','R','A','N','S','F','O','R','M','A','T','I','O','N','\0'}), oc_s113);
    Object@Object oc_s115 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s111), oc_s113, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=14), oc_s115)//{};
    Object@Object oc_s117 = null;
    JCECipher_JCECipher_String_String_String@JCECipher(new Object@Object(__cid=oc_s97), oc_s103, oc_s109, oc_s115, oc_s117)//{};
    for(int x = 666666; x < 666667; x = x + 111111)
    {
      Object@Object p1_s119 = null;
      toString_int@Integer(new Object@Object(__cid=-2, _int=x), p1_s119);
      Object@Object p2_s121 = null;
      toString_int@Integer(new Object@Object(__cid=-2, _int=x + 1), p2_s121);
      Object@Object p3_s123 = null;
      toString_int@Integer(new Object@Object(__cid=-2, _int=x + 2), p3_s123);
      int plaintext_s125 = 0;
      String@meta(plaintext_s125);
      Object@Object _pac_sc_s126 = null;
      if((p1_s119.__cid) == plaintext_s125)/*Tester.sk:39*/
      {
        Object@Object plaintext_s128 = null;
        getBytes@String(p1_s119, plaintext_s128);
        _pac_sc_s126 = plaintext_s128;
      }
      else
      {
        _pac_sc_s126 = null;
      }
      int IV_s130 = 0;
      String@meta(IV_s130);
      Object@Object _pac_sc_s131 = null;
      if((p2_s121.__cid) == IV_s130)/*Tester.sk:40*/
      {
        Object@Object IV_s133 = null;
        getBytes@String(p2_s121, IV_s133);
        _pac_sc_s131 = IV_s133;
      }
      else
      {
        _pac_sc_s131 = null;
      }
      int key_s135 = 0;
      String@meta(key_s135);
      if((p3_s123.__cid) == key_s135)/*Tester.sk:41*/
      {
        Object@Object key_s138 = null;
        getBytes@String(p3_s123, key_s138);
      }
      Object@Object sk_s140 = null;
      SecretKeySpec_SecretKeySpec@SecretKeySpec(sk_s140);
      int cipherText_s142 = 0;
      JCECipher@meta(cipherText_s142);
      Object@Object _pac_sc_s143 = null;
      if((oc_s117.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s142)._int))/*Tester.sk:43*/
      {
        Object@Object cipherText_s145 = null;
        encrypt_byte_SecretKeySpec_byte@JCECipher(oc_s117, _pac_sc_s126, sk_s140, _pac_sc_s131, cipherText_s145);
        _pac_sc_s143 = cipherText_s145;
      }
      else
      {
        _pac_sc_s143 = null;
      }
      int plaintext2_s147 = 0;
      JCECipher@meta(plaintext2_s147);
      Object@Object _pac_sc_s148 = null;
      if((oc_s117.__cid) == (new Object@Object(__cid=-2, _int=plaintext2_s147)._int))/*Tester.sk:44*/
      {
        Object@Object plaintext2_s150 = null;
        decrypt_byte_SecretKeySpec_byte@JCECipher(oc_s117, _pac_sc_s143, sk_s140, _pac_sc_s131, plaintext2_s150);
        _pac_sc_s148 = plaintext2_s150;
      }
      else
      {
        _pac_sc_s148 = null;
      }
      Object@Object _out_s152 = null;
      arraysEquals_byte_byte@Arrays(_pac_sc_s126, _pac_sc_s148, _out_s152);
      assert (_out_s152._bit); //Assert at Tester.sk:45 (0)
      int _out_s154 = 0;
      Array@meta(_out_s154);
      assert ((_pac_sc_s143.__cid) != _out_s154); //Assert at Tester.sk:46 (0)
    }
  }
  /*Tester.sk:13*/
  
void testOpenSSL (Object self)/*Tester.sk:13*/
  {
    int oc_s156 = 0;
    OpenSSLCipher@meta(oc_s156);
    int oc_s158 = 0;
    String@meta(oc_s158);
    Object@Object oc_s160 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=4), A={'A','E','S','\0'}), oc_s160);
    Object@Object oc_s162 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s158), oc_s160, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=3), oc_s162)//{};
    int oc_s164 = 0;
    String@meta(oc_s164);
    Object@Object oc_s166 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=15), A={'T','R','A','N','S','F','O','R','M','A','T','I','O','N','\0'}), oc_s166);
    Object@Object oc_s168 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s164), oc_s166, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=14), oc_s168)//{};
    Object@Object oc_s170 = null;
    OpenSSLCipher_OpenSSLCipher_String_String@OpenSSLCipher(new Object@Object(__cid=oc_s156), oc_s162, oc_s168, oc_s170)//{};
    for(int x = 666666; x < 666667; x = x + 111111)
    {
      Object@Object p1_s172 = null;
      toString_int@Integer(new Object@Object(__cid=-2, _int=x), p1_s172);
      Object@Object p2_s174 = null;
      toString_int@Integer(new Object@Object(__cid=-2, _int=x + 1), p2_s174);
      Object@Object p3_s176 = null;
      toString_int@Integer(new Object@Object(__cid=-2, _int=x + 2), p3_s176);
      int plaintext_s178 = 0;
      String@meta(plaintext_s178);
      Object@Object _pac_sc_s179 = null;
      if((p1_s172.__cid) == plaintext_s178)/*Tester.sk:21*/
      {
        Object@Object plaintext_s181 = null;
        getBytes@String(p1_s172, plaintext_s181);
        _pac_sc_s179 = plaintext_s181;
      }
      else
      {
        _pac_sc_s179 = null;
      }
      int IV_s183 = 0;
      String@meta(IV_s183);
      Object@Object _pac_sc_s184 = null;
      if((p2_s174.__cid) == IV_s183)/*Tester.sk:22*/
      {
        Object@Object IV_s186 = null;
        getBytes@String(p2_s174, IV_s186);
        _pac_sc_s184 = IV_s186;
      }
      else
      {
        _pac_sc_s184 = null;
      }
      int key_s188 = 0;
      String@meta(key_s188);
      if((p3_s176.__cid) == key_s188)/*Tester.sk:23*/
      {
        Object@Object key_s191 = null;
        getBytes@String(p3_s176, key_s191);
      }
      Object@Object sk_s193 = null;
      SecretKeySpec_SecretKeySpec@SecretKeySpec(sk_s193);
      int cipherText_s195 = 0;
      OpenSSLCipher@meta(cipherText_s195);
      Object@Object _pac_sc_s196 = null;
      if((oc_s170.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s195)._int))/*Tester.sk:25*/
      {
        Object@Object cipherText_s198 = null;
        encrypt_byte_SecretKeySpec_byte@OpenSSLCipher(oc_s170, _pac_sc_s179, sk_s193, _pac_sc_s184, cipherText_s198);
        _pac_sc_s196 = cipherText_s198;
      }
      else
      {
        _pac_sc_s196 = null;
      }
      int plaintext2_s200 = 0;
      OpenSSLCipher@meta(plaintext2_s200);
      Object@Object _pac_sc_s201 = null;
      if((oc_s170.__cid) == (new Object@Object(__cid=-2, _int=plaintext2_s200)._int))/*Tester.sk:26*/
      {
        Object@Object plaintext2_s203 = null;
        decrypt_byte_SecretKeySpec_byte@OpenSSLCipher(oc_s170, _pac_sc_s196, sk_s193, _pac_sc_s184, plaintext2_s203);
        _pac_sc_s201 = plaintext2_s203;
      }
      else
      {
        _pac_sc_s201 = null;
      }
      Object@Object _out_s205 = null;
      arraysEquals_byte_byte@Arrays(_pac_sc_s179, _pac_sc_s201, _out_s205);
      assert (_out_s205._bit); //Assert at Tester.sk:27 (0)
    }
  }
  /* END PACKAGE Tester*/
}
/* BEGIN PACKAGE ICipher*/
package ICipher{
  /* END PACKAGE ICipher*/
}
/* BEGIN PACKAGE HashMap*/
package HashMap{
  struct HashMap {
      @Immutable()
  }
  struct Hashmap extends HashMap@HashMap {
      @Immutable()
  }
  struct Put_object_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      Object v;
      @Immutable()
  }
  struct Putb_object_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      Object v;
      @Immutable()
  }
  struct Removeb_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      @Immutable()
  }
  struct Remove_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      @Immutable()
  }
  struct Get_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      @Immutable()
  }
  struct Containskey_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      @Immutable()
  }
  /* END PACKAGE HashMap*/
}
/* BEGIN PACKAGE ArrayList*/
package ArrayList{
  struct ArrayList {
      @Immutable()
  }
  struct Arraylist extends ArrayList@ArrayList {
      @Immutable()
  }
  struct Add_object extends ArrayList@ArrayList {
      ArrayList self;
      Object e;
      @Immutable()
  }
  struct Addb_object extends ArrayList@ArrayList {
      ArrayList self;
      Object e;
      @Immutable()
  }
  struct Getb_int extends ArrayList@ArrayList {
      ArrayList self;
      Object i;
      @Immutable()
  }
  struct Setb_int_object extends ArrayList@ArrayList {
      ArrayList self;
      Object i;
      Object e;
      @Immutable()
  }
  struct Get_int extends ArrayList@ArrayList {
      ArrayList self;
      Object i;
      @Immutable()
  }
  struct Set_int_object extends ArrayList@ArrayList {
      ArrayList self;
      Object i;
      Object e;
      @Immutable()
  }
  struct Ensurecapacity_int extends ArrayList@ArrayList {
      ArrayList self;
      Object n;
      @Immutable()
  }
  struct Size extends ArrayList@ArrayList {
      ArrayList self;
      @Immutable()
  }
  /* END PACKAGE ArrayList*/
}
/* BEGIN PACKAGE String*/
package String{
  /*String.sk:7*/
  
void String_String_char_int_int (Object self, Object ca, Object offset, Object count, ref Object _out)/*String.sk:7*/
  {
    if(((offset._int) > (new Object@Object(__cid=-2, _int=0)._int)) && ((offset._int) < (ca._array_char.length._int)))/*String.sk:8*/
    {
      Object@Object tmp_s748 = null;
      Wrap_Array_char@array(new Array_char@array(length=count), tmp_s748);
      Object@Object i;
      i = new Object@Object(__cid=-2, _int=0);
      bit __sa0 = (i._int) < (count._int);
      while(__sa0)
      {
        tmp_s748._array_char.A[i._int] = ca._array_char.A[(i._int) + (offset._int)];
        i = new Object@Object(__cid=-2, _int=(i._int) + 1);
        __sa0 = (i._int) < (count._int);
      }
      self._value_String = tmp_s748;
    }
    else
    {
      self._value_String = ca;
    }
    self._count_String = count;
    _out = self;
    return;
  }
  /*String.sk:43*/
  
void charAt_int (Object self, Object index, ref Object _out)/*String.sk:43*/
  {
    if(((new Object@Object(__cid=-2, _int=0)._int) <= (index._int)) && ((index._int) < (self._count_String._int)))/*String.sk:44*/
    {
      _out = new Object@Object(__cid=-3, _char=self._value_String._array_char.A[index._int]);
      return;
    }
    _out = new Object@Object(__cid=-3, _char='\0');
    return;
  }
  /*String.sk:214*/
  
void getBytes (Object self, ref Object _out)/*String.sk:214*/
  {
    int _out_s729 = 0;
    String@meta(_out_s729);
    Object@Object _pac_sc_s730 = null;
    if((self.__cid) == (new Object@Object(__cid=-2, _int=_out_s729)._int))/*String.sk:215*/
    {
      Object@Object _out_s732 = null;
      toString@String(self, _out_s732);
      _pac_sc_s730 = _out_s732;
    }
    else
    {
      _pac_sc_s730 = null;
    }
    Object@Object _out_s734 = null;
    getBytes_String(_pac_sc_s730, _out_s734)//{};
    _out = _out_s734;
    return;
  }
  /*String.sk:218*/
  
void getBytes_String (Object str, ref Object _out)/*String.sk:218*/
  {
    int len_s736 = 0;
    String@meta(len_s736);
    Object@Object _pac_sc_s737 = null;
    if((str.__cid) == (new Object@Object(__cid=-2, _int=len_s736)._int))/*String.sk:219*/
    {
      Object@Object len_s739 = null;
      length@String(str, len_s739);
      _pac_sc_s737 = len_s739;
    }
    else
    {
      _pac_sc_s737 = null;
    }
    Object@Object bytes_s741 = null;
    Wrap_Array_char@array(new Array_char@array(length=_pac_sc_s737), bytes_s741);
    _out = bytes_s741;
    Object@Object i;
    i = new Object@Object(__cid=-2, _int=0);
    bit __sa14 = (i._int) < (_pac_sc_s737._int);
    while(__sa14)
    {
      int _out_s743 = 0;
      String@meta(_out_s743);
      Object@Object _pac_sc_s744 = null;
      if((str.__cid) == (new Object@Object(__cid=-2, _int=_out_s743)._int))/*String.sk:222*/
      {
        Object@Object _out_s746 = null;
        charAt_int@String(str, i, _out_s746);
        _pac_sc_s744 = _out_s746;
      }
      else
      {
        _pac_sc_s744 = null;
      }
      bytes_s741._array_char.A[i._int] = _pac_sc_s744._char;
      i = new Object@Object(__cid=-2, _int=(i._int) + 1);
      __sa14 = (i._int) < (_pac_sc_s737._int);
    }
    return;
  }
  /*String.sk:48*/
  
void length (Object self, ref Object _out)/*String.sk:48*/
  {
    _out = self._count_String;
    return;
  }
  /*String.sk:52*/
  
void toString (Object self, ref Object _out)/*String.sk:52*/
  {
    _out = self;
    return;
  }
  /* END PACKAGE String*/
}
/* BEGIN PACKAGE CryptoCipherFactory_CipherProvider*/
package CryptoCipherFactory_CipherProvider{
  /* END PACKAGE CryptoCipherFactory_CipherProvider*/
}
/* BEGIN PACKAGE Properties*/
package Properties{
  /* END PACKAGE Properties*/
}
/* BEGIN PACKAGE Assert*/
package Assert{
  /* END PACKAGE Assert*/
}
/* BEGIN PACKAGE array*/
package array{
  struct Array_bit {
      Object length;
      bit[length._int] A;
  }
  struct Array_char {
      Object length;
      char[length._int] A;
  }
  struct Array_int {
      Object length;
      int[length._int] A;
  }
  struct Array_float {
      Object length;
      float[length._int] A;
  }
  struct Array_double {
      Object length;
      double[length._int] A;
  }
  struct Array_Object {
      Object length;
      Object[length._int] A;
  }
  /*array.sk:37*/
  
void Wrap_Array_char (Array_char arr, ref Object _out)/*array.sk:37*/
  {
    int _out_s1213 = 0;
    Array@meta(_out_s1213);
    _out = new Object@Object(__cid=_out_s1213, _array_char=arr);
    return;
  }
  /* END PACKAGE array*/
}
/* BEGIN PACKAGE SecretKeySpec*/
package SecretKeySpec{
  struct SecretKeySpec {
      @Immutable()
  }
  struct Secretkeyspec extends SecretKeySpec@SecretKeySpec {
      @Immutable()
  }
  struct Getencoded extends SecretKeySpec@SecretKeySpec {
      SecretKeySpec self;
      @Immutable()
  }
  struct Equals_object extends SecretKeySpec@SecretKeySpec {
      SecretKeySpec self;
      Object o;
      @Immutable()
  }
  /*SecretKeySpec.sk:9*/
  
void SecretKeySpec_SecretKeySpec (ref Object _out)/*SecretKeySpec.sk:9*/
  {
    int _out_s1225 = 0;
    SecretKeySpec@meta(_out_s1225);
    _out = new Object@Object(__cid=_out_s1225, _secretkeyspec=new Secretkeyspec());
    return;
  }
  /*SecretKeySpec.sk:34*/
  
void xform_equals_SecretKeySpec_Object (SecretKeySpec self, Object o, ref Object _out)/*SecretKeySpec.sk:34*/
  {
    switch(self){/*SecretKeySpec.sk:35*/
      case Secretkeyspec:
      {
        SecretKeySpec@SecretKeySpec o_o = o._secretkeyspec;
        switch(o_o){/*SecretKeySpec.sk:40*/
          case Secretkeyspec:
          {
            _out = new Object@Object(__cid=-4, _bit=1);
            return;
          }
          case Getencoded:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:40 ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:56 Assert at SecretKeySpec.sk:56 (1)
          case Equals_object:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:40 ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:57 Assert at SecretKeySpec.sk:57 (1)
        }
      }
      case Getencoded:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:35 ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:62 Assert at SecretKeySpec.sk:62 (1)
      case Equals_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:35 ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:63 Assert at SecretKeySpec.sk:63 (1)
    }
    _out = null;
    return;
  }
  /* END PACKAGE SecretKeySpec*/
}
/* BEGIN PACKAGE Boolean*/
package Boolean{
  /* END PACKAGE Boolean*/
}
/* BEGIN PACKAGE OpenSSLCipher*/
package OpenSSLCipher{
  /*OpenSSLCipher.sk:7*/
  
void OpenSSLCipher_OpenSSLCipher_String_String (Object self, Object algorithm, Object transformation, ref Object _out)/*OpenSSLCipher.sk:7*/
  {
    self.algorithm_OpenSSLCipher = algorithm;
    self.transformation_OpenSSLCipher = transformation;
    _out = self;
    return;
  }
  /*OpenSSLCipher.sk:36*/
  
void decrypt_byte_SecretKeySpec_byte (Object self, Object data, Object key, Object IV, ref Object _out)/*OpenSSLCipher.sk:36*/
  {
    Object@Object _out_s1235 = null;
    translate_boolean_byte_SecretKeySpec_byte@OpenSSLCipher(self, new Object@Object(__cid=-4, _bit=0), data, key, IV, _out_s1235);
    _out = _out_s1235;
    return;
  }
  /*OpenSSLCipher.sk:32*/
  
void encrypt_byte_SecretKeySpec_byte (Object self, Object data, Object key, Object IV, ref Object _out)/*OpenSSLCipher.sk:32*/
  {
    Object@Object _out_s1276 = null;
    translate_boolean_byte_SecretKeySpec_byte@OpenSSLCipher(self, new Object@Object(__cid=-4, _bit=1), data, key, IV, _out_s1276);
    _out = _out_s1276;
    return;
  }
  /*OpenSSLCipher.sk:79*/
  
void translate_boolean_byte_SecretKeySpec_byte (Object self, Object isEncryption, Object data, Object key, Object IV, ref Object _out)/*OpenSSLCipher.sk:79*/
  {
    Object@Object _out_s1237 = null;
    Object@Object cipher_s1239 = null;
    getCipher_boolean_SecretKeySpec_byte@JCECipher(self, isEncryption, key, IV, cipher_s1239);
    Object@Object updateBytes_s1241 = null;
    xform_update_Cipher_byte_int_int_byte_int@Cipher(cipher_s1239._cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s1237, new Object@Object(__cid=-2, _int=0), updateBytes_s1241);
    int cipher_s1243 = 0;
    Cipher@meta(cipher_s1243);
    Object@Object _pac_sc_s1244 = null;
    if((cipher_s1239.__cid) == (new Object@Object(__cid=-2, _int=cipher_s1243)._int))/*OpenSSLCipher.sk:51*/
    {
      Object@Object cipher_s1246 = null;
      updateb_Object_byte_int_int_byte_int@Cipher(cipher_s1239, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=6), _out_s1237, new Object@Object(__cid=-2, _int=0), cipher_s1246);
      _pac_sc_s1244 = cipher_s1246;
    }
    else
    {
      _pac_sc_s1244 = null;
    }
    Object@Object finalBytes_s1248 = null;
    xform_doFinale_Cipher_byte_int_int_byte_int@Cipher(_pac_sc_s1244._cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s1237, updateBytes_s1241, finalBytes_s1248);
    int cipher_s1250 = 0;
    Cipher@meta(cipher_s1250);
    Object@Object _pac_sc_s1251 = null;
    if((_pac_sc_s1244.__cid) == (new Object@Object(__cid=-2, _int=cipher_s1250)._int))/*OpenSSLCipher.sk:55*/
    {
      Object@Object cipher_s1253 = null;
      doFinaleb_Object_byte_int_int_byte_int@Cipher(_pac_sc_s1244, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s1237, updateBytes_s1241, cipher_s1253);
      _pac_sc_s1251 = cipher_s1253;
    }
    else
    {
      _pac_sc_s1251 = null;
    }
    if(isEncryption._bit)/*OpenSSLCipher.sk:58*/
    {
      int cipherText_s1255 = 0;
      Cipher@meta(cipherText_s1255);
      Object@Object _pac_sc_s1256 = null;
      if((_pac_sc_s1251.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s1255)._int))/*OpenSSLCipher.sk:59*/
      {
        Object@Object cipherText_s1258 = null;
        doFinal_Object_Object@Cipher(_pac_sc_s1251, data, cipherText_s1258);
        _pac_sc_s1256 = cipherText_s1258;
      }
      else
      {
        _pac_sc_s1256 = null;
      }
      _out_s1237 = _pac_sc_s1256;
      int cipher_s1260 = 0;
      Cipher@meta(cipher_s1260);
      if((_pac_sc_s1251.__cid) == (new Object@Object(__cid=-2, _int=cipher_s1260)._int))/*OpenSSLCipher.sk:60*/
      {
        Object@Object cipher_s1263 = null;
        doFinalb_Object_Object@Cipher(_pac_sc_s1251, data, cipher_s1263);
      }
    }
    else
    {
      Object@Object cipherText_s1265 = null;
      xform_doFinal_Cipher_Object@Cipher(_pac_sc_s1251._cipher, data, cipherText_s1265);
      _out_s1237 = cipherText_s1265;
      int cipher_s1267 = 0;
      Cipher@meta(cipher_s1267);
      if((_pac_sc_s1251.__cid) == (new Object@Object(__cid=-2, _int=cipher_s1267)._int))/*OpenSSLCipher.sk:63*/
      {
        Object@Object cipher_s1270 = null;
        doFinalb_Object_Object@Cipher(_pac_sc_s1251, data, cipher_s1270);
      }
    }
    if(!(isEncryption._bit))/*OpenSSLCipher.sk:67*/
    {
      Object@Object cipherText_s1272 = null;
      copyOf_byte_int@Arrays(_out_s1237, new Object@Object(__cid=-2, _int=(updateBytes_s1241._int) + (finalBytes_s1248._int)), cipherText_s1272);
      _out_s1237 = cipherText_s1272;
    }
    _out = _out_s1237;
    return;
  }
  /* END PACKAGE OpenSSLCipher*/
}
/* BEGIN PACKAGE ANONYMOUS*/
/* END PACKAGE ANONYMOUS*/
/* BEGIN PACKAGE Character*/
package Character{
  /* END PACKAGE Character*/
}
/* BEGIN PACKAGE CharSequence*/
package CharSequence{
  /* END PACKAGE CharSequence*/
}
/* BEGIN PACKAGE SecureRandom*/
package SecureRandom{
  struct SecureRandom {
      @Immutable()
  }
  struct Securerandom extends SecureRandom@SecureRandom {
      @Immutable()
  }
  struct Nextbytes_object extends SecureRandom@SecureRandom {
      SecureRandom self;
      Object k;
      @Immutable()
  }
  /* END PACKAGE SecureRandom*/
}
/* BEGIN PACKAGE CipherFactory*/
package CipherFactory{
  /* END PACKAGE CipherFactory*/
}
/* BEGIN PACKAGE CryptoCipherFactory*/
package CryptoCipherFactory{
  /* END PACKAGE CryptoCipherFactory*/
}
/* BEGIN PACKAGE Mac*/
package Mac{
  struct Mac {
      @Immutable()
  }
  struct Mac_empty extends Mac@Mac {
      @Immutable()
  }
  struct Init_secretkeyspec extends Mac@Mac {
      Mac self;
      Object key;
      @Immutable()
  }
  struct Initb_secretkeyspec extends Mac@Mac {
      Mac self;
      Object key;
      @Immutable()
  }
  struct Dofinal_object extends Mac@Mac {
      Mac self;
      Object text;
      @Immutable()
  }
  /* END PACKAGE Mac*/
}
/* BEGIN PACKAGE Integer*/
package Integer{
  /*Integer.sk:39*/
  
void toString_int (Object i, ref Object _out)/*Integer.sk:39*/
  {
    if((i._int) == (new Object@Object(__cid=-2, _int=0)._int))/*Integer.sk:40*/
    {
      int _out_s1390 = 0;
      String@meta(_out_s1390);
      Object@Object _out_s1392 = null;
      Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=2), A={'0','\0'}), _out_s1392);
      Object@Object _out_s1394 = null;
      String_String_char_int_int@String(new Object@Object(__cid=_out_s1390), _out_s1392, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=1), _out_s1394)//{};
      _out = _out_s1394;
      return;
    }
    Object@Object index = new Object@Object(__cid=-2, _int=0);
    Object@Object temp = i;
    Object@Object j;
    Object@Object ret_s1396 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=32)), ret_s1396);
    Object@Object ret2_s1398 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=32)), ret2_s1398);
    Object@Object nums_s1400 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=10)), nums_s1400);
    nums_s1400._array_char.A[0] = new Object@Object(__cid=-3, _char='0')._char;
    nums_s1400._array_char.A[1] = new Object@Object(__cid=-3, _char='1')._char;
    nums_s1400._array_char.A[2] = new Object@Object(__cid=-3, _char='2')._char;
    nums_s1400._array_char.A[3] = new Object@Object(__cid=-3, _char='3')._char;
    nums_s1400._array_char.A[4] = new Object@Object(__cid=-3, _char='4')._char;
    nums_s1400._array_char.A[5] = new Object@Object(__cid=-3, _char='5')._char;
    nums_s1400._array_char.A[6] = new Object@Object(__cid=-3, _char='6')._char;
    nums_s1400._array_char.A[7] = new Object@Object(__cid=-3, _char='7')._char;
    nums_s1400._array_char.A[8] = new Object@Object(__cid=-3, _char='8')._char;
    nums_s1400._array_char.A[9] = new Object@Object(__cid=-3, _char='9')._char;
    if((i._int) < (new Object@Object(__cid=-2, _int=0)._int))/*Integer.sk:47*/
    {
      temp = new Object@Object(__cid=-2, _int=(i._int) * (-(new Object@Object(__cid=-2, _int=1)._int)));
    }
    bit __sa19 = (temp._int) > (new Object@Object(__cid=-2, _int=0)._int);
    while(__sa19)
    {
      ret_s1396._array_char.A[index._int] = nums_s1400._array_char.A[(temp._int) % (new Object@Object(__cid=-2, _int=10)._int)];
      temp = new Object@Object(__cid=-2, _int=(temp._int) / (new Object@Object(__cid=-2, _int=10)._int));
      index = new Object@Object(__cid=-2, _int=(index._int) + (new Object@Object(__cid=-2, _int=1)._int));
      __sa19 = (temp._int) > (new Object@Object(__cid=-2, _int=0)._int);
    }
    if((i._int) < (new Object@Object(__cid=-2, _int=0)._int))/*Integer.sk:55*/
    {
      ret_s1396._array_char.A[index._int] = new Object@Object(__cid=-3, _char='-')._char;
      index = new Object@Object(__cid=-2, _int=(index._int) + (new Object@Object(__cid=-2, _int=1)._int));
    }
    Object@Object size = index;
    j = new Object@Object(__cid=-2, _int=0);
    bit __sa20 = (j._int) < (index._int);
    while(__sa20)
    {
      ret2_s1398._array_char.A[j._int] = ret_s1396._array_char.A[(index._int) - (new Object@Object(__cid=-2, _int=1)._int)];
      index = new Object@Object(__cid=-2, _int=(index._int) - (new Object@Object(__cid=-2, _int=1)._int));
      j = new Object@Object(__cid=-2, _int=(j._int) + 1);
      __sa20 = (j._int) < (size._int);
    }
    int _out_s1402 = 0;
    String@meta(_out_s1402);
    Object@Object _out_s1404 = null;
    String_String_char_int_int@String(new Object@Object(__cid=_out_s1402), ret2_s1398, new Object@Object(__cid=-2, _int=0), size, _out_s1404)//{};
    _out = _out_s1404;
    return;
  }
  /* END PACKAGE Integer*/
}
/* BEGIN PACKAGE SecretKey*/
package SecretKey{
  /* END PACKAGE SecretKey*/
}
/* BEGIN PACKAGE Utils*/
package Utils{
  /* END PACKAGE Utils*/
}
/* BEGIN PACKAGE meta*/
package meta{
  /*meta.sk:30*/
  
void Array (ref int _out)/*meta.sk:30*/
  {
    _out = -1;
    return;
  }
  /*meta.sk:11*/
  
void Cipher (ref int _out)/*meta.sk:11*/
  {
    _out = 18;
    return;
  }
  /*meta.sk:18*/
  
void IvParameterSpec (ref int _out)/*meta.sk:18*/
  {
    _out = 23;
    return;
  }
  /*meta.sk:19*/
  
void JCECipher (ref int _out)/*meta.sk:19*/
  {
    _out = 4;
    return;
  }
  /*meta.sk:21*/
  
void Object (ref int _out)/*meta.sk:21*/
  {
    _out = 1;
    return;
  }
  /*meta.sk:22*/
  
void OpenSSLCipher (ref int _out)/*meta.sk:22*/
  {
    _out = 6;
    return;
  }
  /*meta.sk:25*/
  
void SecretKeySpec (ref int _out)/*meta.sk:25*/
  {
    _out = 22;
    return;
  }
  /*meta.sk:27*/
  
void String (ref int _out)/*meta.sk:27*/
  {
    _out = 7;
    return;
  }
  /* END PACKAGE meta*/
}
/* BEGIN PACKAGE Byte*/
package Byte{
  /* END PACKAGE Byte*/
}
/* BEGIN PACKAGE Object*/
package Object{
  struct Object {
      int __cid;
      Object bool_Boolean;
      Object value_Integer;
      Object transformation_JCECipher;
      Object algorithm_JCECipher;
      Object provider_JCECipher;
      Object _value_String;
      Object _count_String;
      Object CLASSES_KEY_CryptoCipherFactory;
      Object map_Properties;
      Object value_Character;
      Object transformation_OpenSSLCipher;
      Object algorithm_OpenSSLCipher;
      Object b_Byte;
      Cipher _cipher;
      HashMap _hashmap;
      ArrayList _arraylist;
      SecretKeySpec _secretkeyspec;
      SecureRandom _securerandom;
      Mac _mac;
      Array_bit _array_bit;
      Array_char _array_char;
      Array_int _array_int;
      Array_float _array_float;
      Array_double _array_double;
      Array_Object _array_object;
      bit _bit;
      char _char;
      int _int;
      float _float;
      double _double;
  }
  /*Object.sk:3*/
  
void Object_Object (Object self, ref Object _out)/*Object.sk:3*/
  {
    _out = self;
    return;
  }
  /* END PACKAGE Object*/
}
/* BEGIN PACKAGE IvParameterSpec*/
package IvParameterSpec{
  /*IvParam..erSpec.sk:7*/
  
void IvParameterSpec_IvParameterSpec_byte (Object self, Object val, ref Object _out)/*IvParam..erSpec.sk:7*/
  {
    _out = self;
    return;
  }
  /* END PACKAGE IvParameterSpec*/
}
/* BEGIN PACKAGE Cipher*/
package Cipher{
  struct Cipher {
      @Immutable()
  }
  struct Cipher_empty extends Cipher@Cipher {
      @Immutable()
  }
  struct Cipher_string_string extends Cipher@Cipher {
      Object t;
      Object p;
      @Immutable()
  }
  struct Init_int_secretkeyspec_algorithmparameterspec extends Cipher@Cipher {
      Cipher self;
      Object mode;
      Object s;
      Object a;
      @Immutable()
  }
  struct Initb_int_secretkeyspec_algorithmparameterspec extends Cipher@Cipher {
      Cipher self;
      Object mode;
      Object s;
      Object a;
      @Immutable()
  }
  struct Updateb_byte_int_int_byte_int extends Cipher@Cipher {
      Cipher self;
      Object data;
      Object a;
      Object len;
      Object out;
      Object b;
      @Immutable()
  }
  struct Dofinalb_object extends Cipher@Cipher {
      Cipher self;
      Object data;
      @Immutable()
  }
  struct Dofinaleb_byte_int_int_byte_int extends Cipher@Cipher {
      Cipher self;
      Object data;
      Object a;
      Object b;
      Object out;
      Object c;
      @Immutable()
  }
  struct Update_byte_int_int_byte_int extends Cipher@Cipher {
      Cipher self;
      Object data;
      Object a;
      Object len;
      Object out;
      Object b;
      @Immutable()
  }
  struct Dofinal_object extends Cipher@Cipher {
      Cipher self;
      Object data;
      @Immutable()
  }
  struct Dofinale_byte_int_int_byte_int extends Cipher@Cipher {
      Cipher self;
      Object data;
      Object a;
      Object b;
      Object out;
      Object c;
      @Immutable()
  }
  struct Getoutputsize_int extends Cipher@Cipher {
      Cipher self;
      Object len;
      @Immutable()
  }
  /*Cipher.sk:25*/
  
void Cipher_Object_String_String (Object t, Object p, ref Object _out)/*Cipher.sk:25*/
  {
    int _out_s1553 = 0;
    Cipher@meta(_out_s1553);
    _out = new Object@Object(__cid=_out_s1553, _cipher=new Cipher_string_string(t=t, p=p));
    return;
  }
  /*Cipher.sk:53*/
  
void doFinal_Object_Object (Object self, Object data, ref Object _out)/*Cipher.sk:53*/
  {
    int _out_s1541 = 0;
    Cipher@meta(_out_s1541);
    _out = new Object@Object(__cid=_out_s1541, _cipher=new Dofinal_object(self=self._cipher, data=data));
    return;
  }
  /*Cipher.sk:41*/
  
void doFinalb_Object_Object (Object self, Object data, ref Object _out)/*Cipher.sk:41*/
  {
    int _out_s1537 = 0;
    Cipher@meta(_out_s1537);
    _out = new Object@Object(__cid=_out_s1537, _cipher=new Dofinalb_object(self=self._cipher, data=data));
    return;
  }
  /*Cipher.sk:45*/
  
void doFinaleb_Object_byte_int_int_byte_int (Object self, Object data, Object a, Object b, Object out, Object c, ref Object _out)/*Cipher.sk:45*/
  {
    int _out_s1543 = 0;
    Cipher@meta(_out_s1543);
    _out = new Object@Object(__cid=_out_s1543, _cipher=new Dofinaleb_byte_int_int_byte_int(self=self._cipher, data=data, a=a, b=b, out=out, c=c));
    return;
  }
  /*Cipher.sk:3*/
  
void getInstance_String_String (Object type, Object prov, ref Object _out)/*Cipher.sk:3*/
  {
    Object@Object _out_s1551 = null;
    Cipher_Object_String_String(type, prov, _out_s1551);
    _out = _out_s1551;
    return;
  }
  /*Cipher.sk:29*/
  
void init_Object_int_SecretKeySpec_AlgorithmParameterSpec (Object self, Object mode, Object s, Object a, ref Object _out)/*Cipher.sk:29*/
  {
    int _out_s1549 = 0;
    Cipher@meta(_out_s1549);
    _out = new Object@Object(__cid=_out_s1549, _cipher=new Init_int_secretkeyspec_algorithmparameterspec(self=self._cipher, mode=mode, s=s, a=a));
    return;
  }
  /*Cipher.sk:33*/
  
void initb_Object_int_SecretKeySpec_AlgorithmParameterSpec (Object self, Object mode, Object s, Object a, ref Object _out)/*Cipher.sk:33*/
  {
    int _out_s1547 = 0;
    Cipher@meta(_out_s1547);
    _out = new Object@Object(__cid=_out_s1547, _cipher=new Initb_int_secretkeyspec_algorithmparameterspec(self=self._cipher, mode=mode, s=s, a=a));
    return;
  }
  /*Cipher.sk:37*/
  
void updateb_Object_byte_int_int_byte_int (Object self, Object data, Object a, Object len, Object out, Object b, ref Object _out)/*Cipher.sk:37*/
  {
    int _out_s1545 = 0;
    Cipher@meta(_out_s1545);
    _out = new Object@Object(__cid=_out_s1545, _cipher=new Updateb_byte_int_int_byte_int(self=self._cipher, data=data, a=a, len=len, out=out, b=b));
    return;
  }
  /*Cipher.sk:84*/
  
void xform_doFinal_Cipher_Object (Cipher self, Object data, ref Object _out)/*Cipher.sk:84*/
  {
    switch(self){/*Cipher.sk:85*/
      case Cipher_empty:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:86 Assert at Cipher.sk:86 (1)
      case Cipher_string_string:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:87 Assert at Cipher.sk:87 (1)
      case Init_int_secretkeyspec_algorithmparameterspec:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:88 Assert at Cipher.sk:88 (1)
      case Initb_int_secretkeyspec_algorithmparameterspec:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:89 Assert at Cipher.sk:89 (1)
      case Updateb_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:90 Assert at Cipher.sk:90 (1)
      case Dofinalb_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:91 Assert at Cipher.sk:91 (1)
      case Dofinaleb_byte_int_int_byte_int:
      {
        Cipher@Cipher self_self = self.self;
        switch(self_self){/*Cipher.sk:96*/
          case Cipher_empty:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:97 Assert at Cipher.sk:97 (1)
          case Cipher_string_string:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:98 Assert at Cipher.sk:98 (1)
          case Init_int_secretkeyspec_algorithmparameterspec:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:99 Assert at Cipher.sk:99 (1)
          case Initb_int_secretkeyspec_algorithmparameterspec:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:100 Assert at Cipher.sk:100 (1)
          case Updateb_byte_int_int_byte_int:
          {
            Cipher@Cipher self_self_self = self_self.self;
            switch(self_self_self){/*Cipher.sk:105*/
              case Cipher_empty:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:106 Assert at Cipher.sk:106 (1)
              case Cipher_string_string:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:107 Assert at Cipher.sk:107 (1)
              case Init_int_secretkeyspec_algorithmparameterspec:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:108 Assert at Cipher.sk:108 (1)
              case Initb_int_secretkeyspec_algorithmparameterspec:
              {
                Cipher@Cipher data_data = data._cipher;
                switch(data_data){/*Cipher.sk:113*/
                  case Cipher_empty:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:114 Assert at Cipher.sk:114 (1)
                  case Cipher_string_string:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:115 Assert at Cipher.sk:115 (1)
                  case Init_int_secretkeyspec_algorithmparameterspec:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:116 Assert at Cipher.sk:116 (1)
                  case Initb_int_secretkeyspec_algorithmparameterspec:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:117 Assert at Cipher.sk:117 (1)
                  case Updateb_byte_int_int_byte_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:118 Assert at Cipher.sk:118 (1)
                  case Dofinalb_object:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:119 Assert at Cipher.sk:119 (1)
                  case Dofinaleb_byte_int_int_byte_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:120 Assert at Cipher.sk:120 (1)
                  case Update_byte_int_int_byte_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:121 Assert at Cipher.sk:121 (1)
                  case Dofinal_object:
                  {
                    Cipher@Cipher data_data_data = data_data.self;
                    switch(data_data_data){/*Cipher.sk:126*/
                      case Cipher_empty:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:127 Assert at Cipher.sk:127 (1)
                      case Cipher_string_string:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:128 Assert at Cipher.sk:128 (1)
                      case Init_int_secretkeyspec_algorithmparameterspec:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:129 Assert at Cipher.sk:129 (1)
                      case Initb_int_secretkeyspec_algorithmparameterspec:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:130 Assert at Cipher.sk:130 (1)
                      case Updateb_byte_int_int_byte_int:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:131 Assert at Cipher.sk:131 (1)
                      case Dofinalb_object:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:132 Assert at Cipher.sk:132 (1)
                      case Dofinaleb_byte_int_int_byte_int:
                      {
                        Cipher@Cipher data_data_data_data = data_data_data.self;
                        switch(data_data_data_data){/*Cipher.sk:137*/
                          case Cipher_empty:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:138 Assert at Cipher.sk:138 (1)
                          case Cipher_string_string:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:139 Assert at Cipher.sk:139 (1)
                          case Init_int_secretkeyspec_algorithmparameterspec:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:140 Assert at Cipher.sk:140 (1)
                          case Initb_int_secretkeyspec_algorithmparameterspec:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:141 Assert at Cipher.sk:141 (1)
                          case Updateb_byte_int_int_byte_int:
                          {
                            Cipher@Cipher data_data_data_data_data = data_data_data_data.self;
                            switch(data_data_data_data_data){/*Cipher.sk:146*/
                              case Cipher_empty:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:147 Assert at Cipher.sk:147 (1)
                              case Cipher_string_string:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:148 Assert at Cipher.sk:148 (1)
                              case Init_int_secretkeyspec_algorithmparameterspec:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:149 Assert at Cipher.sk:149 (1)
                              case Initb_int_secretkeyspec_algorithmparameterspec:
                              {
                                Object@Object cond_s1539 = null;
                                xform_equals_SecretKeySpec_Object@SecretKeySpec(self_self_self.s._secretkeyspec, data_data_data_data_data.s, cond_s1539);
                                if(cond_s1539._bit)/*Cipher.sk:152*/
                                {
                                  _out = data_data.data;
                                  return;
                                }
                                else
                                {
                                  _out = null;
                                  return;
                                }
                              }
                              case Updateb_byte_int_int_byte_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:159 Assert at Cipher.sk:159 (1)
                              case Dofinalb_object:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:160 Assert at Cipher.sk:160 (1)
                              case Dofinaleb_byte_int_int_byte_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:161 Assert at Cipher.sk:161 (1)
                              case Update_byte_int_int_byte_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:162 Assert at Cipher.sk:162 (1)
                              case Dofinal_object:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:163 Assert at Cipher.sk:163 (1)
                              case Dofinale_byte_int_int_byte_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:164 Assert at Cipher.sk:164 (1)
                              case Getoutputsize_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:165 Assert at Cipher.sk:165 (1)
                            }
                          }
                          case Dofinalb_object:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:170 Assert at Cipher.sk:170 (1)
                          case Dofinaleb_byte_int_int_byte_int:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:171 Assert at Cipher.sk:171 (1)
                          case Update_byte_int_int_byte_int:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:172 Assert at Cipher.sk:172 (1)
                          case Dofinal_object:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:173 Assert at Cipher.sk:173 (1)
                          case Dofinale_byte_int_int_byte_int:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:174 Assert at Cipher.sk:174 (1)
                          case Getoutputsize_int:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:175 Assert at Cipher.sk:175 (1)
                        }
                      }
                      case Update_byte_int_int_byte_int:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:180 Assert at Cipher.sk:180 (1)
                      case Dofinal_object:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:181 Assert at Cipher.sk:181 (1)
                      case Dofinale_byte_int_int_byte_int:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:182 Assert at Cipher.sk:182 (1)
                      case Getoutputsize_int:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:183 Assert at Cipher.sk:183 (1)
                    }
                  }
                  case Dofinale_byte_int_int_byte_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:188 Assert at Cipher.sk:188 (1)
                  case Getoutputsize_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:189 Assert at Cipher.sk:189 (1)
                }
              }
              case Updateb_byte_int_int_byte_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:194 Assert at Cipher.sk:194 (1)
              case Dofinalb_object:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:195 Assert at Cipher.sk:195 (1)
              case Dofinaleb_byte_int_int_byte_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:196 Assert at Cipher.sk:196 (1)
              case Update_byte_int_int_byte_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:197 Assert at Cipher.sk:197 (1)
              case Dofinal_object:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:198 Assert at Cipher.sk:198 (1)
              case Dofinale_byte_int_int_byte_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:199 Assert at Cipher.sk:199 (1)
              case Getoutputsize_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:200 Assert at Cipher.sk:200 (1)
            }
          }
          case Dofinalb_object:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:205 Assert at Cipher.sk:205 (1)
          case Dofinaleb_byte_int_int_byte_int:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:206 Assert at Cipher.sk:206 (1)
          case Update_byte_int_int_byte_int:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:207 Assert at Cipher.sk:207 (1)
          case Dofinal_object:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:208 Assert at Cipher.sk:208 (1)
          case Dofinale_byte_int_int_byte_int:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:209 Assert at Cipher.sk:209 (1)
          case Getoutputsize_int:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:210 Assert at Cipher.sk:210 (1)
        }
      }
      case Update_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:215 Assert at Cipher.sk:215 (1)
      case Dofinal_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:216 Assert at Cipher.sk:216 (1)
      case Dofinale_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:217 Assert at Cipher.sk:217 (1)
      case Getoutputsize_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:218 Assert at Cipher.sk:218 (1)
    }
    _out = null;
    return;
  }
  /*Cipher.sk:257*/
  
void xform_doFinale_Cipher_byte_int_int_byte_int (Cipher self, Object data, Object a, Object b, Object out, Object c, ref Object _out)/*Cipher.sk:257*/
  {
    switch(self){/*Cipher.sk:258*/
      case Cipher_empty:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:259 Assert at Cipher.sk:259 (1)
      case Cipher_string_string:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:260 Assert at Cipher.sk:260 (1)
      case Init_int_secretkeyspec_algorithmparameterspec:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:261 Assert at Cipher.sk:261 (1)
      case Initb_int_secretkeyspec_algorithmparameterspec:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:262 Assert at Cipher.sk:262 (1)
      case Updateb_byte_int_int_byte_int:
      {
        _out = self.len;
        return;
      }
      case Dofinalb_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:266 Assert at Cipher.sk:266 (1)
      case Dofinaleb_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:267 Assert at Cipher.sk:267 (1)
      case Update_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:268 Assert at Cipher.sk:268 (1)
      case Dofinal_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:269 Assert at Cipher.sk:269 (1)
      case Dofinale_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:270 Assert at Cipher.sk:270 (1)
      case Getoutputsize_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:271 Assert at Cipher.sk:271 (1)
    }
    _out = null;
    return;
  }
  /*Cipher.sk:293*/
  
void xform_update_Cipher_byte_int_int_byte_int (Cipher self, Object data, Object a, Object len, Object out, Object b, ref Object _out)/*Cipher.sk:293*/
  {
    _out = new Object@Object(__cid=-2, _int=0);
    return;
  }
  /* END PACKAGE Cipher*/
}
/* BEGIN PACKAGE Arrays*/
package Arrays{
  /*Arrays.sk:20*/
  
void arraysEquals_byte_byte (Object b1, Object b2, ref Object _out)/*Arrays.sk:20*/
  {
    if((b1._array_char.length._int) == (b2._array_char.length._int))/*Arrays.sk:21*/
    {
      Object@Object i;
      i = new Object@Object(__cid=-2, _int=0);
      bit __sa22 = (i._int) < (b1._array_char.length._int);
      while(__sa22)
      {
        if((b1._array_char.A[i._int]) != (b2._array_char.A[i._int]))/*Arrays.sk:23*/
        {
          _out = new Object@Object(__cid=-4, _bit=0);
          return;
        }
        i = new Object@Object(__cid=-2, _int=(i._int) + 1);
        __sa22 = (i._int) < (b1._array_char.length._int);
      }
    }
    else
    {
      _out = new Object@Object(__cid=-4, _bit=0);
      return;
    }
    _out = new Object@Object(__cid=-4, _bit=1);
    return;
  }
  /*Arrays.sk:7*/
  
void copyOf_byte_int (Object in, Object len, ref Object _out)/*Arrays.sk:7*/
  {
    Object@Object n_s1565 = null;
    Wrap_Array_char@array(new Array_char@array(length=len), n_s1565);
    _out = n_s1565;
    Object@Object i;
    i = new Object@Object(__cid=-2, _int=0);
    bit __sa21 = (i._int) < (len._int);
    while(__sa21)
    {
      if((i._int) >= (in._array_char.length._int))/*Arrays.sk:10*/
      {
        n_s1565._array_char.A[i._int] = new Object@Object(__cid=-2, _int=0)._int;
      }
      else
      {
        n_s1565._array_char.A[i._int] = in._array_char.A[i._int];
      }
      i = new Object@Object(__cid=-2, _int=(i._int) + 1);
      __sa21 = (i._int) < (len._int);
    }
    return;
  }
  /* END PACKAGE Arrays*/
}
[SKETCH] DONE
Total time = 4251
