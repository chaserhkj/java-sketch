SKETCH version 1.7.5
Benchmark = /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/sk_Tester/main.sk
array.sk:5: Making final Array_bit@array.length
array.sk:5: Making final Object._int
array.sk:10: Making final Array_char@array.length
array.sk:15: Making final Array_int@array.length
array.sk:20: Making final Array_float@array.length
array.sk:25: Making final Array_double@array.length
array.sk:30: Making final Array_Object@array.length
[SATBackend] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[SATBackend] MAX LOOP UNROLLING = 35
[SATBackend] MAX FUNC INLINING  = 2
estimated size of main__Wrapper_Tester
stmt cnt: 2
callee main_Tester : 16

[SATBackend] After prog.accept(partialEval)
[SATBackend] OFILE = sk_Tester
searching for file null
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/cegis/src/SketchSolver/cegis
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/cegis
searching for file cegis/src/SketchSolver/cegis
searching for file ../sketch-backend/src/SketchSolver/cegis
searching for file ../sketch-backend/bindings/cegis
searching for file /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/cegis-1.7.5
searching for file /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/cegis
searching for file /usr/bin/cegis
searching for file /usr/bin/src/SketchSolver/cegis
searching for file /usr/bin/../sketch-backend/src/SketchSolver/cegis
searching for file /usr/bin/../sketch-backend/bindings/cegis
searching for file /bin/cegis
searching for file /bin/src/SketchSolver/cegis
searching for file /bin/../sketch-backend/src/SketchSolver/cegis
searching for file /bin/../sketch-backend/bindings/cegis
searching for file /usr/sbin/cegis
searching for file /usr/sbin/src/SketchSolver/cegis
searching for file /usr/sbin/../sketch-backend/src/SketchSolver/cegis
searching for file /usr/sbin/../sketch-backend/bindings/cegis
searching for file /sbin/cegis
searching for file /sbin/src/SketchSolver/cegis
searching for file /sbin/../sketch-backend/src/SketchSolver/cegis
searching for file /sbin/../sketch-backend/bindings/cegis
searching for file /usr/local/bin/cegis
searching for file /usr/local/bin/src/SketchSolver/cegis
searching for file /usr/local/bin/../sketch-backend/src/SketchSolver/cegis
searching for file /usr/local/bin/../sketch-backend/bindings/cegis
searching for file /Applications/Racket v6.10/bin/cegis
searching for file /Applications/Racket v6.10/bin/src/SketchSolver/cegis
searching for file /Applications/Racket v6.10/bin/../sketch-backend/src/SketchSolver/cegis
searching for file /Applications/Racket v6.10/bin/../sketch-backend/bindings/cegis
searching for file /Library/TeX/texbin/cegis
searching for file /Library/TeX/texbin/src/SketchSolver/cegis
searching for file /Library/TeX/texbin/../sketch-backend/src/SketchSolver/cegis
searching for file /Library/TeX/texbin/../sketch-backend/bindings/cegis
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/cegis
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/src/SketchSolver/cegis
searching for file /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-frontend/../sketch-backend/src/SketchSolver/cegis
resolved cegis to path /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-backend/src/SketchSolver/cegis
[SATBackend] Launching: /Users/kathymariano/Research/sketch-from-zip/sketch-1.7.5/sketch-backend/src/SketchSolver/cegis --bnd-inbits 5 --boundmode CALLNAME --verbosity 13 --print-version -simiters 4 --assumebcheck --bnd-inline-amnt 2 -angelictupledepth 1 -srctupledepth 2 -sprandbias 1 -o /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/tmp/sk_Tester/solution0-0 /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/tmp/sk_Tester/input0.tmp 
Overriding inputs with 5
boundmode = CALLNAME
assuming  bounds checks
SOLVER RAND SEED = 1520261639
 optimization level = 6
Reading SKETCH Program in File /Users/kathymariano/Research/java-sketch2/test/axioms/examples/Kafka/sketch_final/tmp/sk_Tester/input0.tmp
CREATING main__Wrapper_Tester
size = 4
after ba size = 4
CREATING main__WrapperNospec_Tester
size = 0
after ba size = 0
CREATING main_Tester
size = 117
after ba size = 117
CREATING Object_meta
size = 3
after ba size = 3
CREATING Object_Object_Object
size = 34
after ba size = 34
CREATING testOpenSSL_Tester
size = 4877
after ba size = 4877
CREATING testJCECipher_Tester
size = 4990
after ba size = 4990
CREATING OpenSSLCipher_meta
size = 3
after ba size = 3
CREATING String_meta
size = 3
after ba size = 3
CREATING Wrap_Array_char_array
size = 44
after ba size = 44
CREATING String_String_char_int_int_String
size = 2297
after ba size = 2297
CREATING OpenSSLCipher_OpenSSLCipher_String_String_OpenSSLCipher
size = 44
after ba size = 44
CREATING SecretKeySpec_SecretKeySpec_SecretKeySpec
size = 44
after ba size = 44
CREATING encrypt_byte_SecretKeySpec_byte_OpenSSLCipher
size = 84
after ba size = 84
CREATING decrypt_byte_SecretKeySpec_byte_OpenSSLCipher
size = 85
after ba size = 85
CREATING arraysEquals_byte_byte_Arrays
size = 2899
after ba size = 2899
CREATING Array_meta
size = 3
after ba size = 3
CREATING JCECipher_meta
size = 3
after ba size = 3
CREATING JCECipher_JCECipher_String_String_String_JCECipher
size = 46
after ba size = 46
CREATING encrypt_byte_SecretKeySpec_byte_JCECipher
size = 84
after ba size = 84
CREATING decrypt_byte_SecretKeySpec_byte_JCECipher
size = 85
after ba size = 85
CREATING SecretKeySpec_meta
size = 3
after ba size = 3
CREATING translate_boolean_byte_SecretKeySpec_byte_OpenSSLCipher
Found Cycle of size 33; Breaking.
size = 2838
after ba size = 2838
CREATING translate_boolean_byte_SecretKeySpec_byte_JCECipher
Found Cycle of size 34; Breaking.
size = 1897
after ba size = 1897
CREATING getCipher_boolean_SecretKeySpec_byte_JCECipher
size = 498
after ba size = 498
CREATING xform_update_Cipher_byte_int_int_byte_int_Cipher
size = 46
after ba size = 46
CREATING Cipher_meta
size = 3
after ba size = 3
CREATING updateb_Object_byte_int_int_byte_int_Cipher
size = 55
after ba size = 55
CREATING xform_doFinale_Cipher_byte_int_int_byte_int_Cipher
size = 213
after ba size = 213
CREATING doFinaleb_Object_byte_int_int_byte_int_Cipher
size = 55
after ba size = 55
CREATING doFinal_Object_Object_Cipher
size = 51
after ba size = 51
CREATING doFinalb_Object_Object_Cipher
size = 51
after ba size = 51
CREATING xform_doFinal_Cipher_Object_Cipher
size = 1251
after ba size = 1251
CREATING copyOf_byte_int_Arrays
size = 3459
after ba size = 3459
CREATING getInstance_String_String_Cipher
size = 71
after ba size = 71
CREATING IvParameterSpec_meta
size = 3
after ba size = 3
CREATING IvParameterSpec_IvParameterSpec_byte_IvParameterSpec
size = 35
after ba size = 35
CREATING init_Object_int_SecretKeySpec_AlgorithmParameterSpec_Cipher
size = 53
after ba size = 53
CREATING initb_Object_int_SecretKeySpec_AlgorithmParameterSpec_Cipher
size = 53
after ba size = 53
CREATING xform_equals_SecretKeySpec_Object_SecretKeySpec
size = 143
after ba size = 143
CREATING Cipher_Object_String_String_Cipher
size = 45
after ba size = 45
* before  EVERYTHING: main__WrapperNospec_Tester::SPEC nodes = 0	 main__Wrapper_Tester::SKETCH nodes = 4
 INBITS = 5
 CBITS  = 5
 input_ints = 0 	 input_bits = 0
 Inlining amount = 2
 Inlining functions in the sketch.
inlined 1 new size =45
inlined 4 new size =9396
inlined 43 new size =16571
inlined 7 new size =25104
Found Cycle of size 50; Breaking.
Found Cycle of size 68; Breaking.
inlined 103 new size =70910
Found Cycle of size 55; Breaking.
Found Cycle of size 114; Breaking.
Found Cycle of size 264; Breaking.
inlined 94 new size =64241
Found Cycle of size 177; Breaking.
inlined 16 new size =23480
inlined 2 new size =23354
inlined 0 new size =23354
END OF STEP 0
 Inlining functions in the spec.
inlined 0 new size =0
END OF STEP 0
Bailing out
after Creating Miter: Problem nodes = 23309
* Final Problem size: Problem nodes = 23309
  # OF CONTROLS:    84
 control_ints = 54 	 control_bits = 30
inputSize = 0	ctrlSize = 408
Random seeds = 1
!+ 011000001111000001001100001010100100010001110000000000000011010000001100100000000010000000100000000001000010000101100000001000101000000000011000000000101101010000110010000000011010100011000001000000001001000000001010100100110010000100100000100010000010001100000001010000100100001010010000010100000010000001100010000010100000001010000001000101101000000001000111001110010000000100001000100010100100000001001010
!+ H__39_183:0
H__37_183:1
H__32_183:1
H__25_183:0
H__24_183:0
H__19_183_182:0
H__17_183_182:0
H__12_183_182:0
H__5_183_182:1
H__4_183_182:1
H__17_183_182_124:1
H__12_183_182_124:1
H__5_183_182_124:0
H__4_183_182_124:0
H__38_183:0
H__18_183_182:0
H__18_183_182_124:0
H__19_183_182_124_183_182_124:1
H__0:12
H__1:42
H__26_183:34
H__27_183:28
H__28_183:0
H__29_183:96
H__30_183:2
H__31_183:38
H__33_183:0
H__34_183:2
H__35_183:4
H__36_183:64
H__6_183_182:16
H__7_183_182:52
H__8_183_182:64
H__9_183_182:40
H__10_183_182:0
H__11_183_182:12
H__13_183_182:64
H__14_183_182:86
H__15_183_182:48
H__16_183_182:2
H__6_183_182_124:88
H__7_183_182_124:98
H__8_183_182_124:32
H__9_183_182_124:0
H__10_183_182_124:9
H__11_183_182_124:32
H__13_183_182_124:37
H__14_183_182_124:38
H__15_183_182_124:72
H__16_183_182_124:32
H__2:4
H__3:98
H__19_125:0
H__17_125:0
H__12_125:0
H__5_125:0
H__4_125:0
H__17_125_124:0
H__12_125_124:0
H__5_125_124:1
H__4_125_124:0
H__18_125:1
H__18_125_124:0
H__19_125_124_125_124:0
H__6_125:36
H__7_125:40
H__8_125:2
H__9_125:5
H__10_125:4
H__11_125:12
H__13_125:65
H__14_125:2
H__15_125:20
H__16_125:16
H__6_125_124:90
H__7_125_124:0
H__8_125_124:98
H__9_125_124:57
H__10_125_124:2
H__11_125_124:4
H__13_125_124:17
H__14_125_124:74
H__15_125_124:0
H__16_125_124:41

BEG CHECK
 * After optims it became = 2 was 23309
Expression to pattern match can't be null: Cipher.sk:258
Simulation found a cex by random testing:  0 ms 
END CHECK
********  0	ftime= 0	ctime= 0.039
!% 
!% 
BEG FIND
Level 1  intsize = 2
 * After optims it became = 23309 was 23309
 * After all optims it became = 23309
 finder  hits = 61560	 bstoreObjs=32341	 sstorePages=29
hitcount 	0	12405	5
hitcount 	1	17767	4
hitcount 	2	678	5
hitcount 	3	67	5
hitcount 	4	28	3
hitcount 	5	54	4
hitcount 	6	25	5
hitcount 	7	17	4
hitcount 	8	19	5
hitcount 	9	19	3
hitcount 	10	8	5
hitcount 	11	17	5
hitcount 	12	12	5
hitcount 	13	9	5
hitcount 	14	8	6
hitcount 	15	9	5
hitcount 	16	8	3
hitcount 	17	7	5
hitcount 	18	7	6
hitcount 	19	8	5
hitcount 	20	7	4
hitcount 	21	7	6
hitcount 	22	7	6
hitcount 	23	18	5
hitcount 	24	11	6
hitcount 	25	7	4
hitcount 	26	7	6
hitcount 	27	8	6
hitcount 	28	13	6
hitcount 	29	7	5
hitcount 	30	8	3
hitcount 	31	9	5
hitcount 	32	7	5
hitcount 	33	8	5
hitcount 	34	15	5
hitcount 	35	1022	5
hitcount 	52	8	5
bucketsPerDepth 	5	2
bucketsPerDepth 	6	27
bucketsPerDepth 	7	66
bucketsPerDepth 	8	169
bucketsPerDepth 	9	248
bucketsPerDepth 	10	195
bucketsPerDepth 	11	160
bucketsPerDepth 	12	80
bucketsPerDepth 	13	39
bucketsPerDepth 	14	21
bucketsPerDepth 	15	10
bucketsPerDepth 	16	3
bucketsPerDepth 	17	4
* TIME TO ADD INPUT :  1000.14 ms 
DECISIONS START = 0
f# %assign: 7 clauses: 90553 learn: 5 restart: 1 decision: 8440 propagated: 50982
END FIND
!+ 111110111101000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000001111010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
!+ H__39_183:1
H__37_183:1
H__32_183:1
H__25_183:1
H__24_183:1
H__19_183_182:0
H__17_183_182:1
H__12_183_182:1
H__5_183_182:1
H__4_183_182:1
H__17_183_182_124:0
H__12_183_182_124:1
H__5_183_182_124:0
H__4_183_182_124:0
H__38_183:0
H__18_183_182:0
H__18_183_182_124:1
H__19_183_182_124_183_182_124:0
H__0:0
H__1:0
H__26_183:0
H__27_183:0
H__28_183:0
H__29_183:0
H__30_183:0
H__31_183:0
H__33_183:0
H__34_183:0
H__35_183:0
H__36_183:0
H__6_183_182:0
H__7_183_182:0
H__8_183_182:0
H__9_183_182:0
H__10_183_182:0
H__11_183_182:0
H__13_183_182:0
H__14_183_182:0
H__15_183_182:0
H__16_183_182:0
H__6_183_182_124:0
H__7_183_182_124:16
H__8_183_182_124:0
H__9_183_182_124:0
H__10_183_182_124:0
H__11_183_182_124:0
H__13_183_182_124:0
H__14_183_182_124:0
H__15_183_182_124:0
H__16_183_182_124:0
H__2:0
H__3:0
H__19_125:0
H__17_125:1
H__12_125:1
H__5_125:1
H__4_125:1
H__17_125_124:0
H__12_125_124:1
H__5_125_124:0
H__4_125_124:1
H__18_125:0
H__18_125_124:0
H__19_125_124_125_124:0
H__6_125:0
H__7_125:0
H__8_125:0
H__9_125:0
H__10_125:0
H__11_125:0
H__13_125:0
H__14_125:0
H__15_125:0
H__16_125:0
H__6_125_124:0
H__7_125_124:0
H__8_125_124:0
H__9_125_124:0
H__10_125_124:0
H__11_125_124:0
H__13_125_124:0
H__14_125_124:0
H__15_125_124:0
H__16_125_124:0

BEG CHECK
 * After optims it became = 0 was 23309
Simulation no cex:  0 ms 
CONTROL: growing l=2 inputs to size 3
Simulation no cex:  0 ms 
CONTROL: growing l=2 inputs to size 4
Simulation no cex:  0 ms 
CONTROL: growing l=2 inputs to size 5
Simulation no cex:  0 ms 
END CHECK
********  1	ftime= 1000.15	ctime= 0.037
 *GOT THE CORRECT ANSWER IN 2 iterations.
 *FIND TIME 1000.15 CHECK TIME 0.076 TOTAL TIME 1000.23
VALUES H__0: 0, H__1: 0, H__10_125: 0, H__10_125_124: 0, H__10_183_182: 0, H__10_183_182_124: 0, H__11_125: 0, H__11_125_124: 0, H__11_183_182: 0, H__11_183_182_124: 0, H__12_125: 1, H__12_125_124: 1, H__12_183_182: 1, H__12_183_182_124: 1, H__13_125: 0, H__13_125_124: 0, H__13_183_182: 0, H__13_183_182_124: 0, H__14_125: 0, H__14_125_124: 0, H__14_183_182: 0, H__14_183_182_124: 0, H__15_125: 0, H__15_125_124: 0, H__15_183_182: 0, H__15_183_182_124: 0, H__16_125: 0, H__16_125_124: 0, H__16_183_182: 0, H__16_183_182_124: 0, H__17_125: 1, H__17_125_124: 0, H__17_183_182: 1, H__17_183_182_124: 0, H__18_125: 0, H__18_125_124: 0, H__18_183_182: 0, H__18_183_182_124: 1, H__19_125: 0, H__19_125_124_125_124: 0, H__19_183_182: 0, H__19_183_182_124_183_182_124: 0, H__2: 0, H__24_183: 1, H__25_183: 1, H__26_183: 0, H__27_183: 0, H__28_183: 0, H__29_183: 0, H__3: 0, H__30_183: 0, H__31_183: 0, H__32_183: 1, H__33_183: 0, H__34_183: 0, H__35_183: 0, H__36_183: 0, H__37_183: 1, H__38_183: 0, H__39_183: 1, H__4_125: 1, H__4_125_124: 1, H__4_183_182: 1, H__4_183_182_124: 0, H__5_125: 1, H__5_125_124: 0, H__5_183_182: 1, H__5_183_182_124: 0, H__6_125: 0, H__6_125_124: 0, H__6_183_182: 0, H__6_183_182_124: 0, H__7_125: 0, H__7_125_124: 0, H__7_183_182: 0, H__7_183_182_124: 16, H__8_125: 0, H__8_125_124: 0, H__8_183_182: 0, H__8_183_182_124: 0, H__9_125: 0, H__9_125_124: 0, H__9_183_182: 0, H__9_183_182_124: 0, 
RESULT = 2  
**ROUND 0 : 0 Round time:  1000.64 ms 
RNDDEG = -1
return 0

----- Statistics -----
Total elapsed time (ms):  2000.51
Model building time (ms): 999.824
Solution time (ms):       1000.64
Max virtual mem (bytes):  0
Max resident mem (bytes): 0
Max private mem (bytes):  0
ALL CORRECT
[SATBackend] Stats for last run:
      [solution stats]
      successful? ---------------------> true
      elapsed time (s) ----------------> 2.683
      model building time (s) ---------> 0.999
      solution time (s) ---------------> 1.0
      max memory usage (MiB) ----------> 0.0
      [SAT-specific solution stats]
      initial number of nodes ---------> -1
      number of nodes after opts ------> -1
      number of controls --------------> -1
      total number of control bits ----> -1

[SATBackend] Solver exit value: 0
[SATBackend] Not Deleting
/* BEGIN PACKAGE JCECipher*/
package JCECipher{
  /*JCECipher.sk:7*/
  
void JCECipher_JCECipher_String_String_String (Object self, Object provider, Object algorithm, Object transformation, ref Object _out)/*JCECipher.sk:7*/
  {
    self.provider_JCECipher = provider;
    self.algorithm_JCECipher = algorithm;
    self.transformation_JCECipher = transformation;
    _out = self;
    return;
  }
  /*JCECipher.sk:34*/
  
void decrypt_byte_SecretKeySpec_byte (Object self, Object data, Object key, Object IV, ref Object _out)/*JCECipher.sk:34*/
  {
    Object@Object _out_s24 = null;
    translate_boolean_byte_SecretKeySpec_byte@JCECipher(self, new Object@Object(__cid=-4, _bit=0), data, key, IV, _out_s24);
    _out = _out_s24;
    return;
  }
  /*JCECipher.sk:30*/
  
void encrypt_byte_SecretKeySpec_byte (Object self, Object data, Object key, Object IV, ref Object _out)/*JCECipher.sk:30*/
  {
    Object@Object _out_s91 = null;
    translate_boolean_byte_SecretKeySpec_byte@JCECipher(self, new Object@Object(__cid=-4, _bit=1), data, key, IV, _out_s91);
    _out = _out_s91;
    return;
  }
  /*JCECipher.sk:14*/
  
void getCipher_boolean_SecretKeySpec_byte (Object self, Object isEncryption, Object key, Object IV, ref Object _out)/*JCECipher.sk:14*/
  {
    Object@Object cipher_s65 = null;
    getInstance_String_String@Cipher(self.transformation_JCECipher, self.provider_JCECipher, cipher_s65);
    Object@Object keyValue_s67 = null;
    SecretKeySpec_SecretKeySpec@SecretKeySpec(keyValue_s67);
    int IVspec_s69 = 0;
    IvParameterSpec@meta(IVspec_s69);
    Object@Object IVspec_s71 = null;
    IvParameterSpec_IvParameterSpec_byte@IvParameterSpec(new Object@Object(__cid=IVspec_s69), IV, IVspec_s71)//{};
    if(isEncryption._bit)/*JCECipher.sk:19*/
    {
      int _out_s73 = 0;
      Cipher@meta(_out_s73);
      if((cipher_s65.__cid) == (new Object@Object(__cid=-2, _int=_out_s73)._int))/*JCECipher.sk:20*/
      {
        Object@Object _out_s75 = null;
        init_Object_int_SecretKeySpec_AlgorithmParameterSpec@Cipher(cipher_s65, new Object@Object(__cid=-2, _int=0), keyValue_s67, IVspec_s71, _out_s75);
      }
      int cipher_s77 = 0;
      Cipher@meta(cipher_s77);
      Object@Object _pac_sc_s78 = null;
      if((cipher_s65.__cid) == (new Object@Object(__cid=-2, _int=cipher_s77)._int))/*JCECipher.sk:21*/
      {
        Object@Object cipher_s80 = null;
        initb_Object_int_SecretKeySpec_AlgorithmParameterSpec@Cipher(cipher_s65, new Object@Object(__cid=-2, _int=0), keyValue_s67, IVspec_s71, cipher_s80);
        _pac_sc_s78 = cipher_s80;
      }
      else
      {
        _pac_sc_s78 = null;
      }
      _out = _pac_sc_s78;
    }
    else
    {
      int _out_s82 = 0;
      Cipher@meta(_out_s82);
      if((cipher_s65.__cid) == (new Object@Object(__cid=-2, _int=_out_s82)._int))/*JCECipher.sk:24*/
      {
        Object@Object _out_s84 = null;
        init_Object_int_SecretKeySpec_AlgorithmParameterSpec@Cipher(cipher_s65, new Object@Object(__cid=-2, _int=0), keyValue_s67, IVspec_s71, _out_s84);
      }
      int cipher_s86 = 0;
      Cipher@meta(cipher_s86);
      Object@Object _pac_sc_s87 = null;
      if((cipher_s65.__cid) == (new Object@Object(__cid=-2, _int=cipher_s86)._int))/*JCECipher.sk:25*/
      {
        Object@Object cipher_s89 = null;
        initb_Object_int_SecretKeySpec_AlgorithmParameterSpec@Cipher(cipher_s65, new Object@Object(__cid=-2, _int=0), keyValue_s67, IVspec_s71, cipher_s89);
        _pac_sc_s87 = cipher_s89;
      }
      else
      {
        _pac_sc_s87 = null;
      }
      _out = _pac_sc_s87;
    }
    return;
  }
  /*JCECipher.sk:78*/
  
void translate_boolean_byte_SecretKeySpec_byte (Object self, Object isEncryption, Object data, Object key, Object IV, ref Object _out)/*JCECipher.sk:78*/
  {
    Object@Object _out_s26 = null;
    Object@Object updateBytes = new Object@Object(__cid=-2, _int=0);
    Object@Object finalBytes = new Object@Object(__cid=-2, _int=0);
    Object@Object cipher = null;
    if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:44*/
    {
      Object@Object cipher_s28 = null;
      getCipher_boolean_SecretKeySpec_byte@JCECipher(self, isEncryption, key, IV, cipher_s28);
      cipher = cipher_s28;
    }
    if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:47*/
    {
      Object@Object updateBytes_s30 = null;
      xform_update_Cipher_byte_int_int_byte_int@Cipher(cipher._cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s26, new Object@Object(__cid=-2, _int=0), updateBytes_s30);
      updateBytes = updateBytes_s30;
      int cipher_s32 = 0;
      Cipher@meta(cipher_s32);
      Object@Object _pac_sc_s33 = null;
      if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipher_s32)._int))/*JCECipher.sk:49*/
      {
        Object@Object cipher_s35 = null;
        updateb_Object_byte_int_int_byte_int@Cipher(cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s26, new Object@Object(__cid=-2, _int=0), cipher_s35);
        _pac_sc_s33 = cipher_s35;
      }
      else
      {
        _pac_sc_s33 = null;
      }
      cipher = _pac_sc_s33;
    }
    if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:51*/
    {
      Object@Object finalBytes_s37 = null;
      xform_doFinale_Cipher_byte_int_int_byte_int@Cipher(cipher._cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s26, updateBytes, finalBytes_s37);
      finalBytes = finalBytes_s37;
      int cipher_s39 = 0;
      Cipher@meta(cipher_s39);
      Object@Object _pac_sc_s40 = null;
      if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipher_s39)._int))/*JCECipher.sk:53*/
      {
        Object@Object cipher_s42 = null;
        doFinaleb_Object_byte_int_int_byte_int@Cipher(cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s26, updateBytes, cipher_s42);
        _pac_sc_s40 = cipher_s42;
      }
      else
      {
        _pac_sc_s40 = null;
      }
      cipher = _pac_sc_s40;
    }
    if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:55*/
    {
      if(isEncryption._bit)/*JCECipher.sk:56*/
      {
        int cipherText_s44 = 0;
        Cipher@meta(cipherText_s44);
        Object@Object _pac_sc_s45 = null;
        if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s44)._int))/*JCECipher.sk:57*/
        {
          Object@Object cipherText_s47 = null;
          doFinal_Object_Object@Cipher(cipher, data, cipherText_s47);
          _pac_sc_s45 = cipherText_s47;
        }
        else
        {
          _pac_sc_s45 = null;
        }
        _out_s26 = _pac_sc_s45;
        int cipher_s49 = 0;
        Cipher@meta(cipher_s49);
        if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipher_s49)._int))/*JCECipher.sk:58*/
        {
          Object@Object cipher_s52 = null;
          doFinalb_Object_Object@Cipher(cipher, data, cipher_s52);
        }
      }
      else
      {
        Object@Object cipherText_s54 = null;
        xform_doFinal_Cipher_Object@Cipher(cipher._cipher, data, cipherText_s54);
        _out_s26 = cipherText_s54;
        int cipher_s56 = 0;
        Cipher@meta(cipher_s56);
        if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipher_s56)._int))/*JCECipher.sk:61*/
        {
          Object@Object cipher_s59 = null;
          doFinalb_Object_Object@Cipher(cipher, data, cipher_s59);
        }
      }
    }
    if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:64*/
    {
      if(!(isEncryption._bit))/*JCECipher.sk:65*/
      {
        if(((updateBytes._int) + (finalBytes._int)) < (_out_s26._array_char.length._int))/*JCECipher.sk:66*/
        {
          Object@Object cipherText_s61 = null;
          copyOf_byte_int@Arrays(_out_s26, new Object@Object(__cid=-2, _int=(updateBytes._int) + (finalBytes._int)), cipherText_s61);
          _out_s26 = cipherText_s61;
        }
      }
    }
    if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:71*/
    {
      Object@Object cipherText_s63 = null;
      Object@Object updateBytes_0 = new Object@Object(__cid=-2, _int=0);
      Object@Object finalBytes_0 = new Object@Object(__cid=-2, _int=0);
      Object@Object cipher_0 = null;
      if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:44*/
      {
        Object@Object cipher_s28_0 = null;
        getCipher_boolean_SecretKeySpec_byte@JCECipher(self, isEncryption, key, IV, cipher_s28_0);
        cipher_0 = cipher_s28_0;
      }
      if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:47*/
      {
        Object@Object updateBytes_s30_0 = null;
        xform_update_Cipher_byte_int_int_byte_int@Cipher(cipher_0._cipher, _out_s26, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s63, new Object@Object(__cid=-2, _int=0), updateBytes_s30_0);
        updateBytes_0 = updateBytes_s30_0;
        int cipher_s32_0 = 0;
        Cipher@meta(cipher_s32_0);
        Object@Object _pac_sc_s33_0 = null;
        if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipher_s32_0)._int))/*JCECipher.sk:49*/
        {
          Object@Object cipher_s35_0 = null;
          updateb_Object_byte_int_int_byte_int@Cipher(cipher_0, _out_s26, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s63, new Object@Object(__cid=-2, _int=0), cipher_s35_0);
          _pac_sc_s33_0 = cipher_s35_0;
        }
        else
        {
          _pac_sc_s33_0 = null;
        }
        cipher_0 = _pac_sc_s33_0;
      }
      if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:51*/
      {
        Object@Object finalBytes_s37_0 = null;
        xform_doFinale_Cipher_byte_int_int_byte_int@Cipher(cipher_0._cipher, _out_s26, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s63, updateBytes_0, finalBytes_s37_0);
        finalBytes_0 = finalBytes_s37_0;
        int cipher_s39_0 = 0;
        Cipher@meta(cipher_s39_0);
        Object@Object _pac_sc_s40_0 = null;
        if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipher_s39_0)._int))/*JCECipher.sk:53*/
        {
          Object@Object cipher_s42_0 = null;
          doFinaleb_Object_byte_int_int_byte_int@Cipher(cipher_0, _out_s26, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s63, updateBytes_0, cipher_s42_0);
          _pac_sc_s40_0 = cipher_s42_0;
        }
        else
        {
          _pac_sc_s40_0 = null;
        }
        cipher_0 = _pac_sc_s40_0;
      }
      if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:55*/
      {
        if(isEncryption._bit)/*JCECipher.sk:56*/
        {
          int cipherText_s44_0 = 0;
          Cipher@meta(cipherText_s44_0);
          Object@Object _pac_sc_s45_0 = null;
          if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s44_0)._int))/*JCECipher.sk:57*/
          {
            Object@Object cipherText_s47_0 = null;
            doFinal_Object_Object@Cipher(cipher_0, _out_s26, cipherText_s47_0);
            _pac_sc_s45_0 = cipherText_s47_0;
          }
          else
          {
            _pac_sc_s45_0 = null;
          }
          cipherText_s63 = _pac_sc_s45_0;
          int cipher_s49_0 = 0;
          Cipher@meta(cipher_s49_0);
          if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipher_s49_0)._int))/*JCECipher.sk:58*/
          {
            Object@Object cipher_s52_0 = null;
            doFinalb_Object_Object@Cipher(cipher_0, _out_s26, cipher_s52_0);
          }
        }
        else
        {
          Object@Object cipherText_s54_0 = null;
          xform_doFinal_Cipher_Object@Cipher(cipher_0._cipher, _out_s26, cipherText_s54_0);
          cipherText_s63 = cipherText_s54_0;
          int cipher_s56_0 = 0;
          Cipher@meta(cipher_s56_0);
          if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipher_s56_0)._int))/*JCECipher.sk:61*/
          {
            Object@Object cipher_s59_0 = null;
            doFinalb_Object_Object@Cipher(cipher_0, _out_s26, cipher_s59_0);
          }
        }
      }
      if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:64*/
      {
        if(!(isEncryption._bit))/*JCECipher.sk:65*/
        {
          if(((updateBytes_0._int) + (finalBytes_0._int)) < (cipherText_s63._array_char.length._int))/*JCECipher.sk:66*/
          {
            Object@Object cipherText_s61_0 = null;
            copyOf_byte_int@Arrays(cipherText_s63, new Object@Object(__cid=-2, _int=(updateBytes_0._int) + (finalBytes_0._int)), cipherText_s61_0);
            cipherText_s63 = cipherText_s61_0;
          }
        }
      }
      assert (!(new Object@Object(__cid=-4, _bit=0)._bit)); //ASSERTION CAN NOT BE SATISFIED: JCECipher.sk:72 Function genCipherText_byte_boolean_SecretKeySpec_byte@JCECipher was not inlined enough. Increase inlining with --inlineamnt flag.
      _out_s26 = cipherText_s63;
    }
    _out = _out_s26;
    return;
  }
  /* END PACKAGE JCECipher*/
}
/* BEGIN PACKAGE Tester*/
package Tester{
  /*Tester.sk:7*/
  
void _main ()/*Tester.sk:7*/
  {
    int self_s93 = 0;
    Object@meta(self_s93);
    Object@Object self_s95 = null;
    Object_Object@Object(new Object@Object(__cid=self_s93), self_s95)//{};
    testOpenSSL@Tester(self_s95);
    testJCECipher@Tester(self_s95);
  }
  /*Tester.sk:7*/
  
void main__Wrapper ()  implements main__WrapperNospec/*Tester.sk:7*/
  {
    _main();
  }
  /*Tester.sk:7*/
  
void main__WrapperNospec ()/*Tester.sk:7*/
  { }
  /*Tester.sk:30*/
  
void testJCECipher (Object self)/*Tester.sk:30*/
  {
    int oc_s97 = 0;
    JCECipher@meta(oc_s97);
    int oc_s99 = 0;
    String@meta(oc_s99);
    Object@Object oc_s101 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=9), A={'P','R','O','V','I','D','E','R','\0'}), oc_s101);
    Object@Object oc_s103 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s99), oc_s101, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=8), oc_s103)//{};
    int oc_s105 = 0;
    String@meta(oc_s105);
    Object@Object oc_s107 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=4), A={'A','E','S','\0'}), oc_s107);
    Object@Object oc_s109 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s105), oc_s107, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=3), oc_s109)//{};
    int oc_s111 = 0;
    String@meta(oc_s111);
    Object@Object oc_s113 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=15), A={'T','R','A','N','S','F','O','R','M','A','T','I','O','N','\0'}), oc_s113);
    Object@Object oc_s115 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s111), oc_s113, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=14), oc_s115)//{};
    Object@Object oc_s117 = null;
    JCECipher_JCECipher_String_String_String@JCECipher(new Object@Object(__cid=oc_s97), oc_s103, oc_s109, oc_s115, oc_s117)//{};
    Object@Object plaintext_s119 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=32)), plaintext_s119);
    Object@Object IV_s121 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=8)), IV_s121);
    Object@Object key_s123 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=128)), key_s123);
    Object@Object i;
    i = new Object@Object(__cid=-2, _int=0);
    bit __sa1 = (i._int) < (new Object@Object(__cid=-2, _int=8)._int);
    while(__sa1)
    {
      key_s123._array_char.A[i._int] = i._int;
      if((i._int) < (new Object@Object(__cid=-2, _int=8)._int))/*Tester.sk:37*/
      {
        plaintext_s119._array_char.A[i._int] = i._int;
      }
      if((i._int) < (new Object@Object(__cid=-2, _int=8)._int))/*Tester.sk:38*/
      {
        IV_s121._array_char.A[i._int] = i._int;
      }
      i = new Object@Object(__cid=-2, _int=(i._int) + 1);
      __sa1 = (i._int) < (new Object@Object(__cid=-2, _int=8)._int);
    }
    Object@Object sk_s125 = null;
    SecretKeySpec_SecretKeySpec@SecretKeySpec(sk_s125);
    int cipherText_s127 = 0;
    JCECipher@meta(cipherText_s127);
    Object@Object _pac_sc_s128 = null;
    if((oc_s117.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s127)._int))/*Tester.sk:41*/
    {
      Object@Object cipherText_s130 = null;
      encrypt_byte_SecretKeySpec_byte@JCECipher(oc_s117, plaintext_s119, sk_s125, IV_s121, cipherText_s130);
      _pac_sc_s128 = cipherText_s130;
    }
    else
    {
      _pac_sc_s128 = null;
    }
    int plaintext2_s132 = 0;
    JCECipher@meta(plaintext2_s132);
    Object@Object _pac_sc_s133 = null;
    if((oc_s117.__cid) == (new Object@Object(__cid=-2, _int=plaintext2_s132)._int))/*Tester.sk:42*/
    {
      Object@Object plaintext2_s135 = null;
      decrypt_byte_SecretKeySpec_byte@JCECipher(oc_s117, _pac_sc_s128, sk_s125, IV_s121, plaintext2_s135);
      _pac_sc_s133 = plaintext2_s135;
    }
    else
    {
      _pac_sc_s133 = null;
    }
    Object@Object _out_s137 = null;
    arraysEquals_byte_byte@Arrays(plaintext_s119, _pac_sc_s133, _out_s137);
    assert (_out_s137._bit); //Assert at Tester.sk:43 (0)
    int _out_s139 = 0;
    Array@meta(_out_s139);
    assert ((_pac_sc_s128.__cid) != _out_s139); //Assert at Tester.sk:44 (0)
  }
  /*Tester.sk:13*/
  
void testOpenSSL (Object self)/*Tester.sk:13*/
  {
    int oc_s141 = 0;
    OpenSSLCipher@meta(oc_s141);
    int oc_s143 = 0;
    String@meta(oc_s143);
    Object@Object oc_s145 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=4), A={'A','E','S','\0'}), oc_s145);
    Object@Object oc_s147 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s143), oc_s145, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=3), oc_s147)//{};
    int oc_s149 = 0;
    String@meta(oc_s149);
    Object@Object oc_s151 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=15), A={'T','R','A','N','S','F','O','R','M','A','T','I','O','N','\0'}), oc_s151);
    Object@Object oc_s153 = null;
    String_String_char_int_int@String(new Object@Object(__cid=oc_s149), oc_s151, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=14), oc_s153)//{};
    Object@Object oc_s155 = null;
    OpenSSLCipher_OpenSSLCipher_String_String@OpenSSLCipher(new Object@Object(__cid=oc_s141), oc_s147, oc_s153, oc_s155)//{};
    Object@Object plaintext_s157 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=32)), plaintext_s157);
    Object@Object IV_s159 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=8)), IV_s159);
    Object@Object key_s161 = null;
    Wrap_Array_char@array(new Array_char@array(length=new Object@Object(__cid=-2, _int=128)), key_s161);
    Object@Object i;
    i = new Object@Object(__cid=-2, _int=0);
    bit __sa0 = (i._int) < (new Object@Object(__cid=-2, _int=8)._int);
    while(__sa0)
    {
      key_s161._array_char.A[i._int] = i._int;
      if((i._int) < (new Object@Object(__cid=-2, _int=8)._int))/*Tester.sk:20*/
      {
        plaintext_s157._array_char.A[i._int] = i._int;
      }
      if((i._int) < (new Object@Object(__cid=-2, _int=8)._int))/*Tester.sk:21*/
      {
        IV_s159._array_char.A[i._int] = i._int;
      }
      i = new Object@Object(__cid=-2, _int=(i._int) + 1);
      __sa0 = (i._int) < (new Object@Object(__cid=-2, _int=8)._int);
    }
    Object@Object sk_s163 = null;
    SecretKeySpec_SecretKeySpec@SecretKeySpec(sk_s163);
    int cipherText_s165 = 0;
    OpenSSLCipher@meta(cipherText_s165);
    Object@Object _pac_sc_s166 = null;
    if((oc_s155.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s165)._int))/*Tester.sk:24*/
    {
      Object@Object cipherText_s168 = null;
      encrypt_byte_SecretKeySpec_byte@OpenSSLCipher(oc_s155, plaintext_s157, sk_s163, IV_s159, cipherText_s168);
      _pac_sc_s166 = cipherText_s168;
    }
    else
    {
      _pac_sc_s166 = null;
    }
    int plaintext2_s170 = 0;
    OpenSSLCipher@meta(plaintext2_s170);
    Object@Object _pac_sc_s171 = null;
    if((oc_s155.__cid) == (new Object@Object(__cid=-2, _int=plaintext2_s170)._int))/*Tester.sk:25*/
    {
      Object@Object plaintext2_s173 = null;
      decrypt_byte_SecretKeySpec_byte@OpenSSLCipher(oc_s155, _pac_sc_s166, sk_s163, IV_s159, plaintext2_s173);
      _pac_sc_s171 = plaintext2_s173;
    }
    else
    {
      _pac_sc_s171 = null;
    }
    Object@Object _out_s175 = null;
    arraysEquals_byte_byte@Arrays(plaintext_s157, _pac_sc_s171, _out_s175);
    assert (_out_s175._bit); //Assert at Tester.sk:26 (0)
    int _out_s177 = 0;
    Array@meta(_out_s177);
    assert ((_pac_sc_s166.__cid) != _out_s177); //Assert at Tester.sk:27 (0)
  }
  /* END PACKAGE Tester*/
}
/* BEGIN PACKAGE ICipher*/
package ICipher{
  /* END PACKAGE ICipher*/
}
/* BEGIN PACKAGE HashMap*/
package HashMap{
  struct HashMap {
      @Immutable()
  }
  struct Hashmap extends HashMap@HashMap {
      @Immutable()
  }
  struct Put_object_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      Object v;
      @Immutable()
  }
  struct Putb_object_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      Object v;
      @Immutable()
  }
  struct Removeb_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      @Immutable()
  }
  struct Remove_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      @Immutable()
  }
  struct Get_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      @Immutable()
  }
  struct Containskey_object extends HashMap@HashMap {
      HashMap self;
      Object k;
      @Immutable()
  }
  /* END PACKAGE HashMap*/
}
/* BEGIN PACKAGE ArrayList*/
package ArrayList{
  struct ArrayList {
      @Immutable()
  }
  struct Arraylist extends ArrayList@ArrayList {
      @Immutable()
  }
  struct Add_object extends ArrayList@ArrayList {
      ArrayList self;
      Object e;
      @Immutable()
  }
  struct Addb_object extends ArrayList@ArrayList {
      ArrayList self;
      Object e;
      @Immutable()
  }
  struct Getb_int extends ArrayList@ArrayList {
      ArrayList self;
      Object i;
      @Immutable()
  }
  struct Setb_int_object extends ArrayList@ArrayList {
      ArrayList self;
      Object i;
      Object e;
      @Immutable()
  }
  struct Get_int extends ArrayList@ArrayList {
      ArrayList self;
      Object i;
      @Immutable()
  }
  struct Set_int_object extends ArrayList@ArrayList {
      ArrayList self;
      Object i;
      Object e;
      @Immutable()
  }
  struct Ensurecapacity_int extends ArrayList@ArrayList {
      ArrayList self;
      Object n;
      @Immutable()
  }
  struct Size extends ArrayList@ArrayList {
      ArrayList self;
      @Immutable()
  }
  /* END PACKAGE ArrayList*/
}
/* BEGIN PACKAGE String*/
package String{
  /*String.sk:7*/
  
void String_String_char_int_int (Object self, Object ca, Object offset, Object count, ref Object _out)/*String.sk:7*/
  {
    if(((offset._int) > (new Object@Object(__cid=-2, _int=0)._int)) && ((offset._int) < (ca._array_char.length._int)))/*String.sk:8*/
    {
      Object@Object tmp_s701 = null;
      Wrap_Array_char@array(new Array_char@array(length=count), tmp_s701);
      Object@Object i;
      i = new Object@Object(__cid=-2, _int=0);
      bit __sa2 = (i._int) < (count._int);
      while(__sa2)
      {
        tmp_s701._array_char.A[i._int] = ca._array_char.A[(i._int) + (offset._int)];
        i = new Object@Object(__cid=-2, _int=(i._int) + 1);
        __sa2 = (i._int) < (count._int);
      }
      self._value_String = tmp_s701;
    }
    else
    {
      self._value_String = ca;
    }
    self._count_String = count;
    _out = self;
    return;
  }
  /* END PACKAGE String*/
}
/* BEGIN PACKAGE CryptoCipherFactory_CipherProvider*/
package CryptoCipherFactory_CipherProvider{
  /* END PACKAGE CryptoCipherFactory_CipherProvider*/
}
/* BEGIN PACKAGE Properties*/
package Properties{
  /* END PACKAGE Properties*/
}
/* BEGIN PACKAGE Assert*/
package Assert{
  /* END PACKAGE Assert*/
}
/* BEGIN PACKAGE array*/
package array{
  struct Array_bit {
      Object length;
      bit[length._int] A;
  }
  struct Array_char {
      Object length;
      char[length._int] A;
  }
  struct Array_int {
      Object length;
      int[length._int] A;
  }
  struct Array_float {
      Object length;
      float[length._int] A;
  }
  struct Array_double {
      Object length;
      double[length._int] A;
  }
  struct Array_Object {
      Object length;
      Object[length._int] A;
  }
  /*array.sk:37*/
  
void Wrap_Array_char (Array_char arr, ref Object _out)/*array.sk:37*/
  {
    int _out_s1185 = 0;
    Array@meta(_out_s1185);
    _out = new Object@Object(__cid=_out_s1185, _array_char=arr);
    return;
  }
  /* END PACKAGE array*/
}
/* BEGIN PACKAGE SecretKeySpec*/
package SecretKeySpec{
  struct SecretKeySpec {
      @Immutable()
  }
  struct Secretkeyspec extends SecretKeySpec@SecretKeySpec {
      @Immutable()
  }
  struct Getencoded extends SecretKeySpec@SecretKeySpec {
      SecretKeySpec self;
      @Immutable()
  }
  struct Equals_object extends SecretKeySpec@SecretKeySpec {
      SecretKeySpec self;
      Object o;
      @Immutable()
  }
  /*SecretKeySpec.sk:9*/
  
void SecretKeySpec_SecretKeySpec (ref Object _out)/*SecretKeySpec.sk:9*/
  {
    int _out_s1197 = 0;
    SecretKeySpec@meta(_out_s1197);
    _out = new Object@Object(__cid=_out_s1197, _secretkeyspec=new Secretkeyspec());
    return;
  }
  /*SecretKeySpec.sk:34*/
  
void xform_equals_SecretKeySpec_Object (SecretKeySpec self, Object o, ref Object _out)/*SecretKeySpec.sk:34*/
  {
    switch(self){/*SecretKeySpec.sk:35*/
      case Secretkeyspec:
      {
        SecretKeySpec@SecretKeySpec o_o = o._secretkeyspec;
        switch(o_o){/*SecretKeySpec.sk:40*/
          case Secretkeyspec:
          {
            _out = new Object@Object(__cid=-4, _bit=1);
            return;
          }
          case Getencoded:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:40 ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:56 Assert at SecretKeySpec.sk:56 (1)
          case Equals_object:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:40 ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:57 Assert at SecretKeySpec.sk:57 (1)
        }
      }
      case Getencoded:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:35 ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:62 Assert at SecretKeySpec.sk:62 (1)
      case Equals_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:35 ASSERTION CAN NOT BE SATISFIED: SecretKeySpec.sk:63 Assert at SecretKeySpec.sk:63 (1)
    }
    _out = null;
    return;
  }
  /* END PACKAGE SecretKeySpec*/
}
/* BEGIN PACKAGE Boolean*/
package Boolean{
  /* END PACKAGE Boolean*/
}
/* BEGIN PACKAGE OpenSSLCipher*/
package OpenSSLCipher{
  /*OpenSSLCipher.sk:7*/
  
void OpenSSLCipher_OpenSSLCipher_String_String (Object self, Object algorithm, Object transformation, ref Object _out)/*OpenSSLCipher.sk:7*/
  {
    self.algorithm_OpenSSLCipher = algorithm;
    self.transformation_OpenSSLCipher = transformation;
    _out = self;
    return;
  }
  /*OpenSSLCipher.sk:36*/
  
void decrypt_byte_SecretKeySpec_byte (Object self, Object data, Object key, Object IV, ref Object _out)/*OpenSSLCipher.sk:36*/
  {
    Object@Object _out_s1207 = null;
    translate_boolean_byte_SecretKeySpec_byte@OpenSSLCipher(self, new Object@Object(__cid=-4, _bit=0), data, key, IV, _out_s1207);
    _out = _out_s1207;
    return;
  }
  /*OpenSSLCipher.sk:32*/
  
void encrypt_byte_SecretKeySpec_byte (Object self, Object data, Object key, Object IV, ref Object _out)/*OpenSSLCipher.sk:32*/
  {
    Object@Object _out_s1248 = null;
    translate_boolean_byte_SecretKeySpec_byte@OpenSSLCipher(self, new Object@Object(__cid=-4, _bit=1), data, key, IV, _out_s1248);
    _out = _out_s1248;
    return;
  }
  /*OpenSSLCipher.sk:79*/
  
void translate_boolean_byte_SecretKeySpec_byte (Object self, Object isEncryption, Object data, Object key, Object IV, ref Object _out)/*OpenSSLCipher.sk:79*/
  {
    Object@Object _out_s1209 = null;
    Object@Object updateBytes = new Object@Object(__cid=-2, _int=0);
    Object@Object finalBytes = new Object@Object(__cid=-2, _int=0);
    Object@Object cipher = null;
    if(new Object@Object(__cid=-4, _bit=1)._bit)/*OpenSSLCipher.sk:46*/
    {
      Object@Object cipher_s1211 = null;
      getCipher_boolean_SecretKeySpec_byte@JCECipher(self, isEncryption, key, IV, cipher_s1211);
      cipher = cipher_s1211;
    }
    if(new Object@Object(__cid=-4, _bit=1)._bit)/*OpenSSLCipher.sk:49*/
    {
      Object@Object updateBytes_s1213 = null;
      xform_update_Cipher_byte_int_int_byte_int@Cipher(cipher._cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s1209, new Object@Object(__cid=-2, _int=0), updateBytes_s1213);
      updateBytes = updateBytes_s1213;
      int cipher_s1215 = 0;
      Cipher@meta(cipher_s1215);
      Object@Object _pac_sc_s1216 = null;
      if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipher_s1215)._int))/*OpenSSLCipher.sk:51*/
      {
        Object@Object cipher_s1218 = null;
        updateb_Object_byte_int_int_byte_int@Cipher(cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s1209, new Object@Object(__cid=-2, _int=0), cipher_s1218);
        _pac_sc_s1216 = cipher_s1218;
      }
      else
      {
        _pac_sc_s1216 = null;
      }
      cipher = _pac_sc_s1216;
    }
    if(new Object@Object(__cid=-4, _bit=1)._bit)/*OpenSSLCipher.sk:53*/
    {
      Object@Object finalBytes_s1220 = null;
      xform_doFinale_Cipher_byte_int_int_byte_int@Cipher(cipher._cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s1209, updateBytes, finalBytes_s1220);
      finalBytes = finalBytes_s1220;
      int cipher_s1222 = 0;
      Cipher@meta(cipher_s1222);
      Object@Object _pac_sc_s1223 = null;
      if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipher_s1222)._int))/*OpenSSLCipher.sk:55*/
      {
        Object@Object cipher_s1225 = null;
        doFinaleb_Object_byte_int_int_byte_int@Cipher(cipher, data, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), _out_s1209, updateBytes, cipher_s1225);
        _pac_sc_s1223 = cipher_s1225;
      }
      else
      {
        _pac_sc_s1223 = null;
      }
      cipher = _pac_sc_s1223;
    }
    if(new Object@Object(__cid=-4, _bit=1)._bit)/*OpenSSLCipher.sk:57*/
    {
      if(isEncryption._bit)/*OpenSSLCipher.sk:58*/
      {
        int cipherText_s1227 = 0;
        Cipher@meta(cipherText_s1227);
        Object@Object _pac_sc_s1228 = null;
        if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s1227)._int))/*OpenSSLCipher.sk:59*/
        {
          Object@Object cipherText_s1230 = null;
          doFinal_Object_Object@Cipher(cipher, data, cipherText_s1230);
          _pac_sc_s1228 = cipherText_s1230;
        }
        else
        {
          _pac_sc_s1228 = null;
        }
        _out_s1209 = _pac_sc_s1228;
        int cipher_s1232 = 0;
        Cipher@meta(cipher_s1232);
        if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipher_s1232)._int))/*OpenSSLCipher.sk:60*/
        {
          Object@Object cipher_s1235 = null;
          doFinalb_Object_Object@Cipher(cipher, data, cipher_s1235);
        }
      }
      else
      {
        Object@Object cipherText_s1237 = null;
        xform_doFinal_Cipher_Object@Cipher(cipher._cipher, data, cipherText_s1237);
        _out_s1209 = cipherText_s1237;
        int cipher_s1239 = 0;
        Cipher@meta(cipher_s1239);
        if((cipher.__cid) == (new Object@Object(__cid=-2, _int=cipher_s1239)._int))/*OpenSSLCipher.sk:63*/
        {
          Object@Object cipher_s1242 = null;
          doFinalb_Object_Object@Cipher(cipher, data, cipher_s1242);
        }
      }
    }
    if(new Object@Object(__cid=-4, _bit=0)._bit)/*OpenSSLCipher.sk:66*/
    {
      if(!(isEncryption._bit))/*OpenSSLCipher.sk:67*/
      {
        Object@Object cipherText_s1244 = null;
        copyOf_byte_int@Arrays(_out_s1209, new Object@Object(__cid=-2, _int=(updateBytes._int) + (finalBytes._int)), cipherText_s1244);
        _out_s1209 = cipherText_s1244;
      }
    }
    if(new Object@Object(__cid=-4, _bit=1)._bit)/*OpenSSLCipher.sk:71*/
    {
      Object@Object cipherText_s1246 = null;
      Object@Object updateBytes_0 = new Object@Object(__cid=-2, _int=0);
      Object@Object finalBytes_0 = new Object@Object(__cid=-2, _int=0);
      Object@Object cipher_0 = null;
      if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:44*/
      {
        Object@Object cipher_s28 = null;
        getCipher_boolean_SecretKeySpec_byte@JCECipher(self, isEncryption, key, IV, cipher_s28);
        cipher_0 = cipher_s28;
      }
      if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:47*/
      {
        Object@Object updateBytes_s30 = null;
        xform_update_Cipher_byte_int_int_byte_int@Cipher(cipher_0._cipher, _out_s1209, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s1246, new Object@Object(__cid=-2, _int=0), updateBytes_s30);
        updateBytes_0 = updateBytes_s30;
        int cipher_s32 = 0;
        Cipher@meta(cipher_s32);
        Object@Object _pac_sc_s33 = null;
        if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipher_s32)._int))/*JCECipher.sk:49*/
        {
          Object@Object cipher_s35 = null;
          updateb_Object_byte_int_int_byte_int@Cipher(cipher_0, _out_s1209, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s1246, new Object@Object(__cid=-2, _int=0), cipher_s35);
          _pac_sc_s33 = cipher_s35;
        }
        else
        {
          _pac_sc_s33 = null;
        }
        cipher_0 = _pac_sc_s33;
      }
      if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:51*/
      {
        Object@Object finalBytes_s37 = null;
        xform_doFinale_Cipher_byte_int_int_byte_int@Cipher(cipher_0._cipher, _out_s1209, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s1246, updateBytes_0, finalBytes_s37);
        finalBytes_0 = finalBytes_s37;
        int cipher_s39 = 0;
        Cipher@meta(cipher_s39);
        Object@Object _pac_sc_s40 = null;
        if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipher_s39)._int))/*JCECipher.sk:53*/
        {
          Object@Object cipher_s42 = null;
          doFinaleb_Object_byte_int_int_byte_int@Cipher(cipher_0, _out_s1209, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s1246, updateBytes_0, cipher_s42);
          _pac_sc_s40 = cipher_s42;
        }
        else
        {
          _pac_sc_s40 = null;
        }
        cipher_0 = _pac_sc_s40;
      }
      if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:55*/
      {
        if(isEncryption._bit)/*JCECipher.sk:56*/
        {
          int cipherText_s44 = 0;
          Cipher@meta(cipherText_s44);
          Object@Object _pac_sc_s45 = null;
          if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s44)._int))/*JCECipher.sk:57*/
          {
            Object@Object cipherText_s47 = null;
            doFinal_Object_Object@Cipher(cipher_0, _out_s1209, cipherText_s47);
            _pac_sc_s45 = cipherText_s47;
          }
          else
          {
            _pac_sc_s45 = null;
          }
          cipherText_s1246 = _pac_sc_s45;
          int cipher_s49 = 0;
          Cipher@meta(cipher_s49);
          if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipher_s49)._int))/*JCECipher.sk:58*/
          {
            Object@Object cipher_s52 = null;
            doFinalb_Object_Object@Cipher(cipher_0, _out_s1209, cipher_s52);
          }
        }
        else
        {
          Object@Object cipherText_s54 = null;
          xform_doFinal_Cipher_Object@Cipher(cipher_0._cipher, _out_s1209, cipherText_s54);
          cipherText_s1246 = cipherText_s54;
          int cipher_s56 = 0;
          Cipher@meta(cipher_s56);
          if((cipher_0.__cid) == (new Object@Object(__cid=-2, _int=cipher_s56)._int))/*JCECipher.sk:61*/
          {
            Object@Object cipher_s59 = null;
            doFinalb_Object_Object@Cipher(cipher_0, _out_s1209, cipher_s59);
          }
        }
      }
      if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:64*/
      {
        if(!(isEncryption._bit))/*JCECipher.sk:65*/
        {
          if(((updateBytes_0._int) + (finalBytes_0._int)) < (cipherText_s1246._array_char.length._int))/*JCECipher.sk:66*/
          {
            Object@Object cipherText_s61 = null;
            copyOf_byte_int@Arrays(cipherText_s1246, new Object@Object(__cid=-2, _int=(updateBytes_0._int) + (finalBytes_0._int)), cipherText_s61);
            cipherText_s1246 = cipherText_s61;
          }
        }
      }
      if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:71*/
      {
        Object@Object cipherText_s63 = null;
        Object@Object updateBytes_1 = new Object@Object(__cid=-2, _int=0);
        Object@Object finalBytes_1 = new Object@Object(__cid=-2, _int=0);
        Object@Object cipher_1 = null;
        if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:44*/
        {
          Object@Object cipher_s28_0 = null;
          getCipher_boolean_SecretKeySpec_byte@JCECipher(self, isEncryption, key, IV, cipher_s28_0);
          cipher_1 = cipher_s28_0;
        }
        if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:47*/
        {
          Object@Object updateBytes_s30_0 = null;
          xform_update_Cipher_byte_int_int_byte_int@Cipher(cipher_1._cipher, cipherText_s1246, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=16), cipherText_s63, new Object@Object(__cid=-2, _int=0), updateBytes_s30_0);
          updateBytes_1 = updateBytes_s30_0;
          int cipher_s32_0 = 0;
          Cipher@meta(cipher_s32_0);
          Object@Object _pac_sc_s33_0 = null;
          if((cipher_1.__cid) == (new Object@Object(__cid=-2, _int=cipher_s32_0)._int))/*JCECipher.sk:49*/
          {
            Object@Object cipher_s35_0 = null;
            updateb_Object_byte_int_int_byte_int@Cipher(cipher_1, cipherText_s1246, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s63, new Object@Object(__cid=-2, _int=0), cipher_s35_0);
            _pac_sc_s33_0 = cipher_s35_0;
          }
          else
          {
            _pac_sc_s33_0 = null;
          }
          cipher_1 = _pac_sc_s33_0;
        }
        if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:51*/
        {
          Object@Object finalBytes_s37_0 = null;
          xform_doFinale_Cipher_byte_int_int_byte_int@Cipher(cipher_1._cipher, cipherText_s1246, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s63, updateBytes_1, finalBytes_s37_0);
          finalBytes_1 = finalBytes_s37_0;
          int cipher_s39_0 = 0;
          Cipher@meta(cipher_s39_0);
          Object@Object _pac_sc_s40_0 = null;
          if((cipher_1.__cid) == (new Object@Object(__cid=-2, _int=cipher_s39_0)._int))/*JCECipher.sk:53*/
          {
            Object@Object cipher_s42_0 = null;
            doFinaleb_Object_byte_int_int_byte_int@Cipher(cipher_1, cipherText_s1246, new Object@Object(__cid=-2, _int=0), new Object@Object(__cid=-2, _int=0), cipherText_s63, updateBytes_1, cipher_s42_0);
            _pac_sc_s40_0 = cipher_s42_0;
          }
          else
          {
            _pac_sc_s40_0 = null;
          }
          cipher_1 = _pac_sc_s40_0;
        }
        if(new Object@Object(__cid=-4, _bit=0)._bit)/*JCECipher.sk:55*/
        {
          if(isEncryption._bit)/*JCECipher.sk:56*/
          {
            int cipherText_s44_0 = 0;
            Cipher@meta(cipherText_s44_0);
            Object@Object _pac_sc_s45_0 = null;
            if((cipher_1.__cid) == (new Object@Object(__cid=-2, _int=cipherText_s44_0)._int))/*JCECipher.sk:57*/
            {
              Object@Object cipherText_s47_0 = null;
              doFinal_Object_Object@Cipher(cipher_1, cipherText_s1246, cipherText_s47_0);
              _pac_sc_s45_0 = cipherText_s47_0;
            }
            else
            {
              _pac_sc_s45_0 = null;
            }
            cipherText_s63 = _pac_sc_s45_0;
            int cipher_s49_0 = 0;
            Cipher@meta(cipher_s49_0);
            if((cipher_1.__cid) == (new Object@Object(__cid=-2, _int=cipher_s49_0)._int))/*JCECipher.sk:58*/
            {
              Object@Object cipher_s52_0 = null;
              doFinalb_Object_Object@Cipher(cipher_1, cipherText_s1246, cipher_s52_0);
            }
          }
          else
          {
            Object@Object cipherText_s54_0 = null;
            xform_doFinal_Cipher_Object@Cipher(cipher_1._cipher, cipherText_s1246, cipherText_s54_0);
            cipherText_s63 = cipherText_s54_0;
            int cipher_s56_0 = 0;
            Cipher@meta(cipher_s56_0);
            if((cipher_1.__cid) == (new Object@Object(__cid=-2, _int=cipher_s56_0)._int))/*JCECipher.sk:61*/
            {
              Object@Object cipher_s59_0 = null;
              doFinalb_Object_Object@Cipher(cipher_1, cipherText_s1246, cipher_s59_0);
            }
          }
        }
        if(new Object@Object(__cid=-4, _bit=1)._bit)/*JCECipher.sk:64*/
        {
          if(!(isEncryption._bit))/*JCECipher.sk:65*/
          {
            if(((updateBytes_1._int) + (finalBytes_1._int)) < (cipherText_s63._array_char.length._int))/*JCECipher.sk:66*/
            {
              Object@Object cipherText_s61_0 = null;
              copyOf_byte_int@Arrays(cipherText_s63, new Object@Object(__cid=-2, _int=(updateBytes_1._int) + (finalBytes_1._int)), cipherText_s61_0);
              cipherText_s63 = cipherText_s61_0;
            }
          }
        }
        assert (!(new Object@Object(__cid=-4, _bit=0)._bit)); //ASSERTION CAN NOT BE SATISFIED: JCECipher.sk:72 Function genCipherText_byte_boolean_SecretKeySpec_byte@JCECipher was not inlined enough. Increase inlining with --inlineamnt flag.
        cipherText_s1246 = cipherText_s63;
      }
      _out_s1209 = cipherText_s1246;
    }
    _out = _out_s1209;
    return;
  }
  /* END PACKAGE OpenSSLCipher*/
}
/* BEGIN PACKAGE ANONYMOUS*/
/* END PACKAGE ANONYMOUS*/
/* BEGIN PACKAGE Character*/
package Character{
  /* END PACKAGE Character*/
}
/* BEGIN PACKAGE CharSequence*/
package CharSequence{
  /* END PACKAGE CharSequence*/
}
/* BEGIN PACKAGE SecureRandom*/
package SecureRandom{
  struct SecureRandom {
      @Immutable()
  }
  struct Securerandom extends SecureRandom@SecureRandom {
      @Immutable()
  }
  struct Nextbytes_object extends SecureRandom@SecureRandom {
      SecureRandom self;
      Object k;
      @Immutable()
  }
  /* END PACKAGE SecureRandom*/
}
/* BEGIN PACKAGE CipherFactory*/
package CipherFactory{
  /* END PACKAGE CipherFactory*/
}
/* BEGIN PACKAGE CryptoCipherFactory*/
package CryptoCipherFactory{
  /* END PACKAGE CryptoCipherFactory*/
}
/* BEGIN PACKAGE Mac*/
package Mac{
  struct Mac {
      @Immutable()
  }
  struct Mac_empty extends Mac@Mac {
      @Immutable()
  }
  struct Init_secretkeyspec extends Mac@Mac {
      Mac self;
      Object key;
      @Immutable()
  }
  struct Initb_secretkeyspec extends Mac@Mac {
      Mac self;
      Object key;
      @Immutable()
  }
  struct Dofinal_object extends Mac@Mac {
      Mac self;
      Object text;
      @Immutable()
  }
  /* END PACKAGE Mac*/
}
/* BEGIN PACKAGE Integer*/
package Integer{
  /* END PACKAGE Integer*/
}
/* BEGIN PACKAGE SecretKey*/
package SecretKey{
  /* END PACKAGE SecretKey*/
}
/* BEGIN PACKAGE Utils*/
package Utils{
  /* END PACKAGE Utils*/
}
/* BEGIN PACKAGE meta*/
package meta{
  /*meta.sk:30*/
  
void Array (ref int _out)/*meta.sk:30*/
  {
    _out = -1;
    return;
  }
  /*meta.sk:11*/
  
void Cipher (ref int _out)/*meta.sk:11*/
  {
    _out = 18;
    return;
  }
  /*meta.sk:18*/
  
void IvParameterSpec (ref int _out)/*meta.sk:18*/
  {
    _out = 23;
    return;
  }
  /*meta.sk:19*/
  
void JCECipher (ref int _out)/*meta.sk:19*/
  {
    _out = 4;
    return;
  }
  /*meta.sk:21*/
  
void Object (ref int _out)/*meta.sk:21*/
  {
    _out = 1;
    return;
  }
  /*meta.sk:22*/
  
void OpenSSLCipher (ref int _out)/*meta.sk:22*/
  {
    _out = 6;
    return;
  }
  /*meta.sk:25*/
  
void SecretKeySpec (ref int _out)/*meta.sk:25*/
  {
    _out = 22;
    return;
  }
  /*meta.sk:27*/
  
void String (ref int _out)/*meta.sk:27*/
  {
    _out = 7;
    return;
  }
  /* END PACKAGE meta*/
}
/* BEGIN PACKAGE Byte*/
package Byte{
  /* END PACKAGE Byte*/
}
/* BEGIN PACKAGE Object*/
package Object{
  struct Object {
      int __cid;
      Object bool_Boolean;
      Object value_Integer;
      Object transformation_JCECipher;
      Object algorithm_JCECipher;
      Object provider_JCECipher;
      Object _value_String;
      Object _count_String;
      Object CLASSES_KEY_CryptoCipherFactory;
      Object map_Properties;
      Object value_Character;
      Object transformation_OpenSSLCipher;
      Object algorithm_OpenSSLCipher;
      Object b_Byte;
      Cipher _cipher;
      HashMap _hashmap;
      ArrayList _arraylist;
      SecretKeySpec _secretkeyspec;
      SecureRandom _securerandom;
      Mac _mac;
      Array_bit _array_bit;
      Array_char _array_char;
      Array_int _array_int;
      Array_float _array_float;
      Array_double _array_double;
      Array_Object _array_object;
      bit _bit;
      char _char;
      int _int;
      float _float;
      double _double;
  }
  /*Object.sk:3*/
  
void Object_Object (Object self, ref Object _out)/*Object.sk:3*/
  {
    _out = self;
    return;
  }
  /* END PACKAGE Object*/
}
/* BEGIN PACKAGE IvParameterSpec*/
package IvParameterSpec{
  /*IvParam..erSpec.sk:7*/
  
void IvParameterSpec_IvParameterSpec_byte (Object self, Object val, ref Object _out)/*IvParam..erSpec.sk:7*/
  {
    _out = self;
    return;
  }
  /* END PACKAGE IvParameterSpec*/
}
/* BEGIN PACKAGE Cipher*/
package Cipher{
  struct Cipher {
      @Immutable()
  }
  struct Cipher_empty extends Cipher@Cipher {
      @Immutable()
  }
  struct Cipher_string_string extends Cipher@Cipher {
      Object t;
      Object p;
      @Immutable()
  }
  struct Init_int_secretkeyspec_algorithmparameterspec extends Cipher@Cipher {
      Cipher self;
      Object mode;
      Object s;
      Object a;
      @Immutable()
  }
  struct Initb_int_secretkeyspec_algorithmparameterspec extends Cipher@Cipher {
      Cipher self;
      Object mode;
      Object s;
      Object a;
      @Immutable()
  }
  struct Updateb_byte_int_int_byte_int extends Cipher@Cipher {
      Cipher self;
      Object data;
      Object a;
      Object len;
      Object out;
      Object b;
      @Immutable()
  }
  struct Dofinalb_object extends Cipher@Cipher {
      Cipher self;
      Object data;
      @Immutable()
  }
  struct Dofinaleb_byte_int_int_byte_int extends Cipher@Cipher {
      Cipher self;
      Object data;
      Object a;
      Object b;
      Object out;
      Object c;
      @Immutable()
  }
  struct Update_byte_int_int_byte_int extends Cipher@Cipher {
      Cipher self;
      Object data;
      Object a;
      Object len;
      Object out;
      Object b;
      @Immutable()
  }
  struct Dofinal_object extends Cipher@Cipher {
      Cipher self;
      Object data;
      @Immutable()
  }
  struct Dofinale_byte_int_int_byte_int extends Cipher@Cipher {
      Cipher self;
      Object data;
      Object a;
      Object b;
      Object out;
      Object c;
      @Immutable()
  }
  struct Getoutputsize_int extends Cipher@Cipher {
      Cipher self;
      Object len;
      @Immutable()
  }
  /*Cipher.sk:25*/
  
void Cipher_Object_String_String (Object t, Object p, ref Object _out)/*Cipher.sk:25*/
  {
    int _out_s1507 = 0;
    Cipher@meta(_out_s1507);
    _out = new Object@Object(__cid=_out_s1507, _cipher=new Cipher_string_string(t=t, p=p));
    return;
  }
  /*Cipher.sk:53*/
  
void doFinal_Object_Object (Object self, Object data, ref Object _out)/*Cipher.sk:53*/
  {
    int _out_s1495 = 0;
    Cipher@meta(_out_s1495);
    _out = new Object@Object(__cid=_out_s1495, _cipher=new Dofinal_object(self=self._cipher, data=data));
    return;
  }
  /*Cipher.sk:41*/
  
void doFinalb_Object_Object (Object self, Object data, ref Object _out)/*Cipher.sk:41*/
  {
    int _out_s1491 = 0;
    Cipher@meta(_out_s1491);
    _out = new Object@Object(__cid=_out_s1491, _cipher=new Dofinalb_object(self=self._cipher, data=data));
    return;
  }
  /*Cipher.sk:45*/
  
void doFinaleb_Object_byte_int_int_byte_int (Object self, Object data, Object a, Object b, Object out, Object c, ref Object _out)/*Cipher.sk:45*/
  {
    int _out_s1497 = 0;
    Cipher@meta(_out_s1497);
    _out = new Object@Object(__cid=_out_s1497, _cipher=new Dofinaleb_byte_int_int_byte_int(self=self._cipher, data=data, a=a, b=b, out=out, c=c));
    return;
  }
  /*Cipher.sk:3*/
  
void getInstance_String_String (Object type, Object prov, ref Object _out)/*Cipher.sk:3*/
  {
    Object@Object _out_s1505 = null;
    Cipher_Object_String_String(type, prov, _out_s1505);
    _out = _out_s1505;
    return;
  }
  /*Cipher.sk:29*/
  
void init_Object_int_SecretKeySpec_AlgorithmParameterSpec (Object self, Object mode, Object s, Object a, ref Object _out)/*Cipher.sk:29*/
  {
    int _out_s1503 = 0;
    Cipher@meta(_out_s1503);
    _out = new Object@Object(__cid=_out_s1503, _cipher=new Init_int_secretkeyspec_algorithmparameterspec(self=self._cipher, mode=mode, s=s, a=a));
    return;
  }
  /*Cipher.sk:33*/
  
void initb_Object_int_SecretKeySpec_AlgorithmParameterSpec (Object self, Object mode, Object s, Object a, ref Object _out)/*Cipher.sk:33*/
  {
    int _out_s1501 = 0;
    Cipher@meta(_out_s1501);
    _out = new Object@Object(__cid=_out_s1501, _cipher=new Initb_int_secretkeyspec_algorithmparameterspec(self=self._cipher, mode=mode, s=s, a=a));
    return;
  }
  /*Cipher.sk:37*/
  
void updateb_Object_byte_int_int_byte_int (Object self, Object data, Object a, Object len, Object out, Object b, ref Object _out)/*Cipher.sk:37*/
  {
    int _out_s1499 = 0;
    Cipher@meta(_out_s1499);
    _out = new Object@Object(__cid=_out_s1499, _cipher=new Updateb_byte_int_int_byte_int(self=self._cipher, data=data, a=a, len=len, out=out, b=b));
    return;
  }
  /*Cipher.sk:84*/
  
void xform_doFinal_Cipher_Object (Cipher self, Object data, ref Object _out)/*Cipher.sk:84*/
  {
    switch(self){/*Cipher.sk:85*/
      case Cipher_empty:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:86 Assert at Cipher.sk:86 (1)
      case Cipher_string_string:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:87 Assert at Cipher.sk:87 (1)
      case Init_int_secretkeyspec_algorithmparameterspec:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:88 Assert at Cipher.sk:88 (1)
      case Initb_int_secretkeyspec_algorithmparameterspec:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:89 Assert at Cipher.sk:89 (1)
      case Updateb_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:90 Assert at Cipher.sk:90 (1)
      case Dofinalb_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:91 Assert at Cipher.sk:91 (1)
      case Dofinaleb_byte_int_int_byte_int:
      {
        Cipher@Cipher self_self = self.self;
        switch(self_self){/*Cipher.sk:96*/
          case Cipher_empty:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:97 Assert at Cipher.sk:97 (1)
          case Cipher_string_string:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:98 Assert at Cipher.sk:98 (1)
          case Init_int_secretkeyspec_algorithmparameterspec:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:99 Assert at Cipher.sk:99 (1)
          case Initb_int_secretkeyspec_algorithmparameterspec:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:100 Assert at Cipher.sk:100 (1)
          case Updateb_byte_int_int_byte_int:
          {
            Cipher@Cipher self_self_self = self_self.self;
            switch(self_self_self){/*Cipher.sk:105*/
              case Cipher_empty:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:106 Assert at Cipher.sk:106 (1)
              case Cipher_string_string:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:107 Assert at Cipher.sk:107 (1)
              case Init_int_secretkeyspec_algorithmparameterspec:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:108 Assert at Cipher.sk:108 (1)
              case Initb_int_secretkeyspec_algorithmparameterspec:
              {
                Cipher@Cipher data_data = data._cipher;
                switch(data_data){/*Cipher.sk:113*/
                  case Cipher_empty:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:114 Assert at Cipher.sk:114 (1)
                  case Cipher_string_string:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:115 Assert at Cipher.sk:115 (1)
                  case Init_int_secretkeyspec_algorithmparameterspec:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:116 Assert at Cipher.sk:116 (1)
                  case Initb_int_secretkeyspec_algorithmparameterspec:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:117 Assert at Cipher.sk:117 (1)
                  case Updateb_byte_int_int_byte_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:118 Assert at Cipher.sk:118 (1)
                  case Dofinalb_object:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:119 Assert at Cipher.sk:119 (1)
                  case Dofinaleb_byte_int_int_byte_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:120 Assert at Cipher.sk:120 (1)
                  case Update_byte_int_int_byte_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:121 Assert at Cipher.sk:121 (1)
                  case Dofinal_object:
                  {
                    Cipher@Cipher data_data_data = data_data.self;
                    switch(data_data_data){/*Cipher.sk:126*/
                      case Cipher_empty:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:127 Assert at Cipher.sk:127 (1)
                      case Cipher_string_string:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:128 Assert at Cipher.sk:128 (1)
                      case Init_int_secretkeyspec_algorithmparameterspec:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:129 Assert at Cipher.sk:129 (1)
                      case Initb_int_secretkeyspec_algorithmparameterspec:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:130 Assert at Cipher.sk:130 (1)
                      case Updateb_byte_int_int_byte_int:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:131 Assert at Cipher.sk:131 (1)
                      case Dofinalb_object:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:132 Assert at Cipher.sk:132 (1)
                      case Dofinaleb_byte_int_int_byte_int:
                      {
                        Cipher@Cipher data_data_data_data = data_data_data.self;
                        switch(data_data_data_data){/*Cipher.sk:137*/
                          case Cipher_empty:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:138 Assert at Cipher.sk:138 (1)
                          case Cipher_string_string:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:139 Assert at Cipher.sk:139 (1)
                          case Init_int_secretkeyspec_algorithmparameterspec:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:140 Assert at Cipher.sk:140 (1)
                          case Initb_int_secretkeyspec_algorithmparameterspec:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:141 Assert at Cipher.sk:141 (1)
                          case Updateb_byte_int_int_byte_int:
                          {
                            Cipher@Cipher data_data_data_data_data = data_data_data_data.self;
                            switch(data_data_data_data_data){/*Cipher.sk:146*/
                              case Cipher_empty:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:147 Assert at Cipher.sk:147 (1)
                              case Cipher_string_string:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:148 Assert at Cipher.sk:148 (1)
                              case Init_int_secretkeyspec_algorithmparameterspec:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:149 Assert at Cipher.sk:149 (1)
                              case Initb_int_secretkeyspec_algorithmparameterspec:
                              {
                                Object@Object cond_s1493 = null;
                                xform_equals_SecretKeySpec_Object@SecretKeySpec(self_self_self.s._secretkeyspec, data_data_data_data_data.s, cond_s1493);
                                if(cond_s1493._bit)/*Cipher.sk:152*/
                                {
                                  _out = data_data.data;
                                  return;
                                }
                                else
                                {
                                  _out = null;
                                  return;
                                }
                              }
                              case Updateb_byte_int_int_byte_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:159 Assert at Cipher.sk:159 (1)
                              case Dofinalb_object:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:160 Assert at Cipher.sk:160 (1)
                              case Dofinaleb_byte_int_int_byte_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:161 Assert at Cipher.sk:161 (1)
                              case Update_byte_int_int_byte_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:162 Assert at Cipher.sk:162 (1)
                              case Dofinal_object:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:163 Assert at Cipher.sk:163 (1)
                              case Dofinale_byte_int_int_byte_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:164 Assert at Cipher.sk:164 (1)
                              case Getoutputsize_int:
                                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:146 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:165 Assert at Cipher.sk:165 (1)
                            }
                          }
                          case Dofinalb_object:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:170 Assert at Cipher.sk:170 (1)
                          case Dofinaleb_byte_int_int_byte_int:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:171 Assert at Cipher.sk:171 (1)
                          case Update_byte_int_int_byte_int:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:172 Assert at Cipher.sk:172 (1)
                          case Dofinal_object:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:173 Assert at Cipher.sk:173 (1)
                          case Dofinale_byte_int_int_byte_int:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:174 Assert at Cipher.sk:174 (1)
                          case Getoutputsize_int:
                            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:137 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:175 Assert at Cipher.sk:175 (1)
                        }
                      }
                      case Update_byte_int_int_byte_int:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:180 Assert at Cipher.sk:180 (1)
                      case Dofinal_object:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:181 Assert at Cipher.sk:181 (1)
                      case Dofinale_byte_int_int_byte_int:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:182 Assert at Cipher.sk:182 (1)
                      case Getoutputsize_int:
                        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:126 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:183 Assert at Cipher.sk:183 (1)
                    }
                  }
                  case Dofinale_byte_int_int_byte_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:188 Assert at Cipher.sk:188 (1)
                  case Getoutputsize_int:
                    assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:113 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:189 Assert at Cipher.sk:189 (1)
                }
              }
              case Updateb_byte_int_int_byte_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:194 Assert at Cipher.sk:194 (1)
              case Dofinalb_object:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:195 Assert at Cipher.sk:195 (1)
              case Dofinaleb_byte_int_int_byte_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:196 Assert at Cipher.sk:196 (1)
              case Update_byte_int_int_byte_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:197 Assert at Cipher.sk:197 (1)
              case Dofinal_object:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:198 Assert at Cipher.sk:198 (1)
              case Dofinale_byte_int_int_byte_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:199 Assert at Cipher.sk:199 (1)
              case Getoutputsize_int:
                assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:105 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:200 Assert at Cipher.sk:200 (1)
            }
          }
          case Dofinalb_object:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:205 Assert at Cipher.sk:205 (1)
          case Dofinaleb_byte_int_int_byte_int:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:206 Assert at Cipher.sk:206 (1)
          case Update_byte_int_int_byte_int:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:207 Assert at Cipher.sk:207 (1)
          case Dofinal_object:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:208 Assert at Cipher.sk:208 (1)
          case Dofinale_byte_int_int_byte_int:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:209 Assert at Cipher.sk:209 (1)
          case Getoutputsize_int:
            assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:96 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:210 Assert at Cipher.sk:210 (1)
        }
      }
      case Update_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:215 Assert at Cipher.sk:215 (1)
      case Dofinal_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:216 Assert at Cipher.sk:216 (1)
      case Dofinale_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:217 Assert at Cipher.sk:217 (1)
      case Getoutputsize_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:85 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:218 Assert at Cipher.sk:218 (1)
    }
    _out = null;
    return;
  }
  /*Cipher.sk:257*/
  
void xform_doFinale_Cipher_byte_int_int_byte_int (Cipher self, Object data, Object a, Object b, Object out, Object c, ref Object _out)/*Cipher.sk:257*/
  {
    switch(self){/*Cipher.sk:258*/
      case Cipher_empty:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:259 Assert at Cipher.sk:259 (1)
      case Cipher_string_string:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:260 Assert at Cipher.sk:260 (1)
      case Init_int_secretkeyspec_algorithmparameterspec:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:261 Assert at Cipher.sk:261 (1)
      case Initb_int_secretkeyspec_algorithmparameterspec:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:262 Assert at Cipher.sk:262 (1)
      case Updateb_byte_int_int_byte_int:
      {
        _out = self.len;
        return;
      }
      case Dofinalb_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:266 Assert at Cipher.sk:266 (1)
      case Dofinaleb_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:267 Assert at Cipher.sk:267 (1)
      case Update_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:268 Assert at Cipher.sk:268 (1)
      case Dofinal_object:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:269 Assert at Cipher.sk:269 (1)
      case Dofinale_byte_int_int_byte_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:270 Assert at Cipher.sk:270 (1)
      case Getoutputsize_int:
        assert (0); //ASSERTION CAN NOT BE SATISFIED: Cipher.sk:258 ASSERTION CAN NOT BE SATISFIED: Cipher.sk:271 Assert at Cipher.sk:271 (1)
    }
    _out = null;
    return;
  }
  /*Cipher.sk:293*/
  
void xform_update_Cipher_byte_int_int_byte_int (Cipher self, Object data, Object a, Object len, Object out, Object b, ref Object _out)/*Cipher.sk:293*/
  {
    _out = new Object@Object(__cid=-2, _int=0);
    return;
  }
  /* END PACKAGE Cipher*/
}
/* BEGIN PACKAGE Arrays*/
package Arrays{
  /*Arrays.sk:20*/
  
void arraysEquals_byte_byte (Object b1, Object b2, ref Object _out)/*Arrays.sk:20*/
  {
    if((b1._array_char.length._int) == (b2._array_char.length._int))/*Arrays.sk:21*/
    {
      Object@Object i;
      i = new Object@Object(__cid=-2, _int=0);
      bit __sa22 = (i._int) < (b1._array_char.length._int);
      while(__sa22)
      {
        if((b1._array_char.A[i._int]) != (b2._array_char.A[i._int]))/*Arrays.sk:23*/
        {
          _out = new Object@Object(__cid=-4, _bit=0);
          return;
        }
        i = new Object@Object(__cid=-2, _int=(i._int) + 1);
        __sa22 = (i._int) < (b1._array_char.length._int);
      }
    }
    else
    {
      _out = new Object@Object(__cid=-4, _bit=0);
      return;
    }
    _out = new Object@Object(__cid=-4, _bit=1);
    return;
  }
  /*Arrays.sk:7*/
  
void copyOf_byte_int (Object in, Object len, ref Object _out)/*Arrays.sk:7*/
  {
    Object@Object n_s1519 = null;
    Wrap_Array_char@array(new Array_char@array(length=len), n_s1519);
    _out = n_s1519;
    Object@Object i;
    i = new Object@Object(__cid=-2, _int=0);
    bit __sa21 = (i._int) < (len._int);
    while(__sa21)
    {
      if((i._int) >= (in._array_char.length._int))/*Arrays.sk:10*/
      {
        n_s1519._array_char.A[i._int] = new Object@Object(__cid=-2, _int=0)._int;
      }
      else
      {
        n_s1519._array_char.A[i._int] = in._array_char.A[i._int];
      }
      i = new Object@Object(__cid=-2, _int=(i._int) + 1);
      __sa21 = (i._int) < (len._int);
    }
    return;
  }
  /* END PACKAGE Arrays*/
}
[SKETCH] DONE
Total time = 5913
