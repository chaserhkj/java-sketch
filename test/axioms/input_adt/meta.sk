package meta;

adt T {
  Str    { int n; char[n] s; }
  Len    { T t; }
  Concat { T t1; T t2; }
  Plus   { T left; T right; }
  Error  { }
}

// Construct string with concrete values
/* Object string([int n], char[n] s) { return new Object(__cid=String(),str=new Str(n=n,s=s)); } */
Object string()                  { return new Object(__cid=String(),t=new Str()); }
Object length(T t)               { return new Object(__cid=String(),t=new Len(t=t)); }
Object concat(T t1, T t2)        { return new Object(__cid=String(),t=new Concat(t1=t1,t2=t2)); }
Object plus(T left, T right)     { return new Object(__cid=String(),t=new Plus(left=left,right=right)); }

generator T xform(T t, int bnd) {
  assert bnd >= 0;
  T t1; T t2 = null; 
  switch(t) {
  case Str:    { return t; }
  case Len:    { t1 = t.t; }
  case Plus:   { t1 = t.left; t2 = t.right; }
  case Concat: { t1 = t.t1; t2 = t.t2; }
  case Error:  { return t; }
  }
  if (t2 != null) {
    t1 = xform(t1, bnd-1);
    t2 = xform(t2, bnd-1);
    switch(t) { // this should only be Plus or Concat
    case Plus:   return new Plus(left=t1, right=t2);
    case Concat: return new Concat(t1=t1, t2=t2);
    case Str:    return new Error(); // should never happen
    case Len:    return new Error();
    case Error:  return t;
    }
  }
  else { // should only be Len
    switch(t1) {
    case Str: return t;
    case Concat: {
      T tt1 = xform(t1.t1, bnd-1); T tt2 = xform(t1.t2, bnd-1);
      return new Plus(left=new Len(t=tt1), right=new Len(t=tt2));
      /* return {| (new Plus(left=new Len(t=tt1), right=new Len(t=tt2)) | */
      /* 		 new Len(t=new Concat(t1=tt1, t2=tt2))) */
      /* 	  |}; */
    }
    case Plus:  return new Error(); // Len(Plus(...))
    case Len:   return new Error();
    case Error: return t;
    }
  }
}

// distinct class IDs
int CharSequence()         { return 3; }
int Object()               { return 1; }
int String()               { return 7; }

// Uninterpreted functions
